{"version":3,"file":"bundle.umd.min.js","sources":["esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["import { BufferedEventEmitter } from \"./bufferedEventEmitter\";\r\nexport class EventProp {\r\n    constructor(name, fn, once, options) {\r\n        this.name = name;\r\n        this.fn = fn;\r\n        this.once = once;\r\n        this.options = options;\r\n        if (options === null || options === void 0 ? void 0 : options.buffered) {\r\n            this.bucket = [];\r\n            this.timeoutID = undefined;\r\n        }\r\n    }\r\n}\r\nexport class EventController {\r\n    flush() { }\r\n    off() { }\r\n}\r\nexport function checkListenerOptionsEquality(obj1, obj2) {\r\n    if (obj1 === obj2)\r\n        return true;\r\n    if (!obj1 || !obj2)\r\n        return false;\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    let key;\r\n    for (key in obj1) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function getListenerIdx(events, listener, options) {\r\n    for (let i = 0; i < events.length; i++) {\r\n        if (events[i].fn === listener && checkListenerOptionsEquality(events[i].options, options)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexport function emitAfterTimeout(payload, ms) {\r\n    let timeoutId;\r\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\r\n        this.emit(payload.eventName, payload.data);\r\n        resolve(true);\r\n    }, ms))).finally(() => {\r\n        clearTimeout(timeoutId);\r\n    });\r\n}\r\nexport function logger(type, eventName, eventData) {\r\n    if ((type === \"emit\" && !BufferedEventEmitter.debugStatus.emit) ||\r\n        (type === \"on\" && !BufferedEventEmitter.debugStatus.on) ||\r\n        (type === \"off\" && !BufferedEventEmitter.debugStatus.off))\r\n        return;\r\n    if (type === \"emit\") {\r\n        try {\r\n            eventData = JSON.stringify(eventData);\r\n        }\r\n        catch (_a) {\r\n            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\r\n        }\r\n    }\r\n    else if ([\"on\", \"off\"].includes(type) && typeof eventData === \"function\") {\r\n        eventData = eventData.toString();\r\n    }\r\n    const currentTime = new Date();\r\n    const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\r\n    console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\r\n    console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\r\n    console.groupEnd();\r\n}\r\nconst controls = new Map();\r\nexport function attachControls(control, eventProp) {\r\n    const eventProps = controls.get(control) || [];\r\n    eventProps.push(eventProp);\r\n    controls.set(control, eventProps);\r\n    control.off = () => {\r\n        eventProps.forEach((p) => {\r\n            this.off(p.name, p.fn, p.options);\r\n        });\r\n    };\r\n    control.flush = () => {\r\n        eventProps.forEach((p) => {\r\n            this.flush(p.name, p.fn, p.options);\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { EventProp, EventController, getListenerIdx, checkListenerOptionsEquality, emitAfterTimeout, logger, attachControls, } from \"./utils\";\r\n// when buffered\r\nconst DEFAULT_BUFFER_CAPACITY = 5;\r\n// when emission paused\r\nconst DEFAULT_EMISSION_INTERVAL = 0;\r\nexport class BufferedEventEmitter {\r\n    constructor(options) {\r\n        var _a, _b, _c;\r\n        this._events = {};\r\n        this._options = {\r\n            buffered: (_a = options === null || options === void 0 ? void 0 : options.buffered) !== null && _a !== void 0 ? _a : false,\r\n            bufferCapacity: (_b = options === null || options === void 0 ? void 0 : options.bufferCapacity) !== null && _b !== void 0 ? _b : DEFAULT_BUFFER_CAPACITY,\r\n            logger: (_c = options === null || options === void 0 ? void 0 : options.logger) !== null && _c !== void 0 ? _c : logger,\r\n        };\r\n        this._status = \"emitting\";\r\n        this._queueEmissions = true;\r\n        this._emissionInterval = DEFAULT_EMISSION_INTERVAL;\r\n        this._queue = [];\r\n    }\r\n    emit(eventName, data) {\r\n        if (!this._events[eventName] || this._events[eventName].length === 0) {\r\n            return false;\r\n        }\r\n        if (this._status === \"paused\") {\r\n            if (this._queueEmissions)\r\n                this._queue.push({ eventName, data });\r\n            return false;\r\n        }\r\n        // collect events here which are !(once && emitted)\r\n        let eventProps = [];\r\n        let didAnyEmit = false;\r\n        // iterate through all registered events\r\n        this._events[eventName].forEach((event) => {\r\n            var _a, _b, _c;\r\n            let didEmit = false;\r\n            // buffered event handling\r\n            if ((_a = event === null || event === void 0 ? void 0 : event.options) === null || _a === void 0 ? void 0 : _a.buffered) {\r\n                (_b = event === null || event === void 0 ? void 0 : event.bucket) === null || _b === void 0 ? void 0 : _b.push(data);\r\n                const bufferCapacity = (_c = event === null || event === void 0 ? void 0 : event.options.bufferCapacity) !== null && _c !== void 0 ? _c : this._options.bufferCapacity;\r\n                if ((event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length >= bufferCapacity) {\r\n                    event.fn(event.bucket);\r\n                    didEmit = true;\r\n                    didAnyEmit = true;\r\n                    this._options.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                }\r\n            }\r\n            else {\r\n                // non-buffered event handling\r\n                event.fn(data);\r\n                didEmit = true;\r\n                didAnyEmit = true;\r\n                this._options.logger(\"emit\", eventName, data);\r\n            }\r\n            // filter out once emitted events\r\n            if (!(event.once && didEmit)) {\r\n                eventProps.push(event);\r\n            }\r\n        });\r\n        this._events[eventName] = eventProps;\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    on(eventName, listener, options) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        // dedupe listeners\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        const eventProp = new EventProp(eventName, listener, false, options);\r\n        if ((options === null || options === void 0 ? void 0 : options.control) instanceof EventController) {\r\n            attachControls.call(this, options.control, eventProp);\r\n        }\r\n        this._events[eventName].push(eventProp);\r\n        this._options.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Adds a one-time event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\r\n     * The first time event is triggered, this listener is invoked and then removed.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns `true` if listener was added `false` otherwise.\r\n     */\r\n    once(eventName, listener, options) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        // dedupe listeners\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        const eventProp = new EventProp(eventName, listener, true, options);\r\n        if ((options === null || options === void 0 ? void 0 : options.control) instanceof EventController) {\r\n            attachControls.call(this, options.control, eventProp);\r\n        }\r\n        this._events[eventName].push(eventProp);\r\n        this._options.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns `true` if listener was removed `false` otherwise.\r\n     */\r\n    off(eventName, listener, options) {\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index === -1)\r\n            return false;\r\n        this._events[eventName].splice(index, 1);\r\n        this._options.logger(\"off\", eventName, listener);\r\n        return true;\r\n    }\r\n    flush(eventName, listener, options) {\r\n        let didAnyEmit = false;\r\n        let emittedOnceListenerIndexes = [];\r\n        this._events[eventName].forEach((event, idx) => {\r\n            var _a;\r\n            if (((_a = event === null || event === void 0 ? void 0 : event.options) === null || _a === void 0 ? void 0 : _a.buffered) && (event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length > 0) {\r\n                const matchesListenerFn = listener && listener === event.fn;\r\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\r\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\r\n                    (eventName && !listener && !options);\r\n                if (shouldFlush) {\r\n                    event.fn(event.bucket);\r\n                    didAnyEmit = true;\r\n                    this._options.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                    if (event.once)\r\n                        emittedOnceListenerIndexes.push(idx);\r\n                }\r\n            }\r\n        });\r\n        this._events[eventName] = this._events[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Pause event emissions. Any subsequent event emissions will be swallowed or queued and\r\n     * their respective listeners will not be invoked until resume() is called.\r\n     * @param queueEmissions if true, subsequent event emissions will be queued else swallowed\r\n     * @param emissionInterval interval in ms for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\r\n     */\r\n    pause(queueEmissions = true, emissionInterval = DEFAULT_EMISSION_INTERVAL) {\r\n        this._queueEmissions = queueEmissions;\r\n        this._emissionInterval = emissionInterval;\r\n        this._status = \"paused\";\r\n    }\r\n    /**\r\n     * Resumes event emission\r\n     * @returns void or Promise depending on emission interval value.\r\n     */\r\n    resume() {\r\n        this._status = \"emitting\";\r\n        if (this._queueEmissions) {\r\n            if (this._emissionInterval > DEFAULT_EMISSION_INTERVAL) {\r\n                const dequeueAsync = () => __awaiter(this, void 0, void 0, function* () {\r\n                    for (const item of this._queue) {\r\n                        yield emitAfterTimeout.call(this, item, this._emissionInterval);\r\n                    }\r\n                });\r\n                return dequeueAsync();\r\n            }\r\n            else {\r\n                this._queue.forEach(({ eventName, data }) => {\r\n                    this.emit(eventName, data);\r\n                });\r\n                this._queue = [];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided event name.\r\n     * @param eventName - event name\r\n     * @returns `true` if any listener was removed for the event `false` otherwise.\r\n     */\r\n    offAll(eventName) {\r\n        var _a;\r\n        if (eventName && ((_a = this._events[eventName]) === null || _a === void 0 ? void 0 : _a.length) > 0) {\r\n            delete this._events[eventName];\r\n            this._queue = this._queue.filter((e) => e.eventName !== eventName);\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    /**\r\n     * Removes all listeners and queued events for the instance.\r\n     */\r\n    cleanup() {\r\n        this._queue = [];\r\n        this._events = {};\r\n    }\r\n    listeners(eventName) {\r\n        if (eventName === undefined) {\r\n            return this._events;\r\n        }\r\n        else {\r\n            return this._events[eventName].map((event) => event.fn);\r\n        }\r\n    }\r\n    /**\r\n     * Enable debugging for all instances of the emitter\r\n     * @param opts\r\n     */\r\n    static enableDebug(opts) {\r\n        BufferedEventEmitter.debugStatus = Object.assign(Object.assign({}, BufferedEventEmitter.debugStatus), opts);\r\n    }\r\n}\r\nBufferedEventEmitter.debugStatus = { emit: false, on: false, off: false };\r\nBufferedEventEmitter.prototype.addListener = BufferedEventEmitter.prototype.on;\r\nBufferedEventEmitter.prototype.removeListener = BufferedEventEmitter.prototype.off;\r\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["EventProp","constructor","name","fn","once","options","this","buffered","bucket","timeoutID","undefined","EventController","flush","off","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","emitAfterTimeout","payload","ms","timeoutId","Promise","resolve","setTimeout","emit","eventName","data","finally","clearTimeout","logger","type","eventData","BufferedEventEmitter","debugStatus","on","JSON","stringify","_a","join","includes","toString","currentTime","Date","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","controls","Map","attachControls","control","eventProp","eventProps","get","push","set","forEach","p","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","_b","_c","_events","_options","bufferCapacity","_status","_queueEmissions","_emissionInterval","_queue","didAnyEmit","event","didEmit","call","index","splice","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","pause","queueEmissions","emissionInterval","resume","item","dequeueAsync","offAll","cleanup","listeners","map","static","opts","assign","prototype","addListener","removeListener"],"mappings":"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"}