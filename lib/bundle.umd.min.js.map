{"version":3,"file":"bundle.umd.min.js","sources":["esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["export class EventProp {\r\n    constructor(fn, once, options) {\r\n        this.fn = fn;\r\n        this.once = once;\r\n        this.options = options;\r\n        if (options === null || options === void 0 ? void 0 : options.buffered) {\r\n            this.bucket = [];\r\n            this.timeoutID = undefined;\r\n        }\r\n    }\r\n}\r\nexport function checkListenerOptionsEquality(obj1, obj2) {\r\n    if (!obj1 || !obj2)\r\n        return false;\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    let key;\r\n    for (key in obj1) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function getListenerIdx(events, listener, options) {\r\n    for (let i = 0; i < events.length; i++) {\r\n        if (events[i].fn === listener && checkListenerOptionsEquality(events[i].options, options)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexport function emitAfterTimeout(payload, ms) {\r\n    let timeoutId;\r\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\r\n        this.emit(payload.eventName, payload.data);\r\n        resolve(true);\r\n    }, ms))).finally(() => {\r\n        clearTimeout(timeoutId);\r\n    });\r\n}\r\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { EventProp, getListenerIdx, checkListenerOptionsEquality, emitAfterTimeout } from \"./utils\";\r\n// when buffered\r\nconst DEFAULT_BUFFER_CAPACITY = 5;\r\n// when emission paused\r\nconst DEFAULT_EMISSION_INTERVAL = 0;\r\nexport class BufferedEventEmitter {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        this._events = {};\r\n        this._defaultListenerOptions = {\r\n            buffered: (_a = options === null || options === void 0 ? void 0 : options.buffered) !== null && _a !== void 0 ? _a : false,\r\n            bufferCapacity: (_b = options === null || options === void 0 ? void 0 : options.bufferCapacity) !== null && _b !== void 0 ? _b : DEFAULT_BUFFER_CAPACITY,\r\n        };\r\n        this._status = \"emitting\";\r\n        this._queueEmissions = true;\r\n        this._emissionInterval = DEFAULT_EMISSION_INTERVAL;\r\n        this._queue = [];\r\n    }\r\n    emit(eventName, data) {\r\n        if (!this._events[eventName] || this._events[eventName].length === 0) {\r\n            return false;\r\n        }\r\n        if (this._status === \"paused\") {\r\n            if (this._queueEmissions)\r\n                this._queue.push({ eventName, data });\r\n            return false;\r\n        }\r\n        // collect events here which are !(once && emitted)\r\n        let eventProps = [];\r\n        let didAnyEmit = false;\r\n        // iterate through all registered events\r\n        this._events[eventName].forEach((event) => {\r\n            var _a, _b;\r\n            let didEmit = false;\r\n            // buffered event handling\r\n            if (event.options.buffered) {\r\n                (_a = event === null || event === void 0 ? void 0 : event.bucket) === null || _a === void 0 ? void 0 : _a.push(data);\r\n                const bufferCapacity = (_b = event.options.bufferCapacity) !== null && _b !== void 0 ? _b : this._defaultListenerOptions.bufferCapacity;\r\n                if ((event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length >= bufferCapacity) {\r\n                    event.fn(event.bucket);\r\n                    didEmit = true;\r\n                    didAnyEmit = true;\r\n                    this.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                }\r\n            }\r\n            else {\r\n                // non-buffered event handling\r\n                event.fn(data);\r\n                didEmit = true;\r\n                didAnyEmit = true;\r\n                this.logger(\"emit\", eventName, data);\r\n            }\r\n            // filter out once emitted events\r\n            if (!(event.once && didEmit)) {\r\n                eventProps.push(event);\r\n            }\r\n        });\r\n        this._events[eventName] = eventProps;\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    on(eventName, listener, options = this._defaultListenerOptions) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        // dedupe listeners\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, false, options));\r\n        this.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Adds a one-time event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\r\n     * The first time event is triggered, this listener is invoked and then removed.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns `true` if listener was added `false` otherwise.\r\n     */\r\n    once(eventName, listener, options = this._defaultListenerOptions) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        // dedupe listeners\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, true, options));\r\n        this.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns `true` if listener was removed `false` otherwise.\r\n     */\r\n    off(eventName, listener, options = this._defaultListenerOptions) {\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index === -1)\r\n            return false;\r\n        this._events[eventName].splice(index, 1);\r\n        this.logger(\"off\", eventName, listener);\r\n        return true;\r\n    }\r\n    flush(eventName, listener, options) {\r\n        let didAnyEmit = false;\r\n        let emittedOnceListenerIndexes = [];\r\n        this._events[eventName].forEach((event, idx) => {\r\n            if (event.options.buffered && (event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length > 0) {\r\n                const matchesListenerFn = listener && listener === event.fn;\r\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\r\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\r\n                    (eventName && !listener && !options);\r\n                if (shouldFlush) {\r\n                    event.fn(event.bucket);\r\n                    didAnyEmit = true;\r\n                    this.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                    if (event.once)\r\n                        emittedOnceListenerIndexes.push(idx);\r\n                }\r\n            }\r\n        });\r\n        this._events[eventName] = this._events[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Pause event emissions. Any subsequent event emissions will be swallowed or queued and\r\n     * their respective listeners will not be invoked until resume() is called.\r\n     * @param queueEmissions if true, subsequent event emissions will be queued else swallowed\r\n     * @param emissionInterval interval in ms for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\r\n     */\r\n    pause(queueEmissions = true, emissionInterval = DEFAULT_EMISSION_INTERVAL) {\r\n        this._queueEmissions = queueEmissions;\r\n        this._emissionInterval = emissionInterval;\r\n        this._status = \"paused\";\r\n    }\r\n    /**\r\n     * Resumes event emission\r\n     * @returns void or Promise depending on emission interval value.\r\n     */\r\n    resume() {\r\n        this._status = \"emitting\";\r\n        if (this._queueEmissions) {\r\n            if (this._emissionInterval > DEFAULT_EMISSION_INTERVAL) {\r\n                const dequeueAsync = () => __awaiter(this, void 0, void 0, function* () {\r\n                    for (const item of this._queue) {\r\n                        yield emitAfterTimeout.call(this, item, this._emissionInterval);\r\n                    }\r\n                });\r\n                return dequeueAsync();\r\n            }\r\n            else {\r\n                this._queue.forEach(({ eventName, data }) => {\r\n                    this.emit(eventName, data);\r\n                });\r\n                this._queue = [];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided event name.\r\n     * @param eventName - event name\r\n     * @returns `true` if any listener was removed for the event `false` otherwise.\r\n     */\r\n    removeListeners(eventName) {\r\n        var _a;\r\n        if (eventName && ((_a = this._events[eventName]) === null || _a === void 0 ? void 0 : _a.length) > 0) {\r\n            delete this._events[eventName];\r\n            this._queue = this._queue.filter((e) => e.eventName !== eventName);\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    /**\r\n     * Removes all listeners and queued events for the instance.\r\n     */\r\n    cleanup() {\r\n        this._queue = [];\r\n        this._events = {};\r\n    }\r\n    listeners(eventName) {\r\n        if (eventName === undefined) {\r\n            return this._events;\r\n        }\r\n        else {\r\n            return this._events[eventName].map((event) => event.fn);\r\n        }\r\n    }\r\n    // aliases\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of listener and options is already present the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    addListener(eventName, listener, options = this._defaultListenerOptions) {\r\n        return this.on(eventName, listener, options);\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName  Name of the event, listener will be added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was removed or not\r\n     */\r\n    removeListener(eventName, listener, options = this._defaultListenerOptions) {\r\n        return this.off(eventName, listener, options);\r\n    }\r\n    logger(type, eventName, eventData) {\r\n        if ((type === \"emit\" && !BufferedEventEmitter.debugStatus.emit) ||\r\n            (type === \"on\" && !BufferedEventEmitter.debugStatus.on) ||\r\n            (type === \"off\" && !BufferedEventEmitter.debugStatus.off))\r\n            return;\r\n        if (type === \"emit\") {\r\n            try {\r\n                eventData = JSON.stringify(eventData);\r\n            }\r\n            catch (_a) {\r\n                eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\r\n            }\r\n        }\r\n        else if (type === \"on\" && typeof eventData === \"function\") {\r\n            eventData = eventData.toString();\r\n        }\r\n        const currentTime = new Date();\r\n        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\r\n        console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\r\n        console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\r\n        console.groupEnd();\r\n    }\r\n    /**\r\n     * Enable debugging for all instances of the emitter\r\n     * @param opts\r\n     */\r\n    static enableDebug(opts) {\r\n        BufferedEventEmitter.debugStatus = Object.assign(Object.assign({}, BufferedEventEmitter.debugStatus), opts);\r\n    }\r\n}\r\nBufferedEventEmitter.debugStatus = { emit: false, on: false, off: false };\r\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["EventProp","constructor","fn","once","options","this","buffered","bucket","timeoutID","undefined","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","emitAfterTimeout","payload","ms","timeoutId","Promise","resolve","setTimeout","emit","eventName","data","finally","clearTimeout","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","BufferedEventEmitter","_a","_b","_events","_defaultListenerOptions","bufferCapacity","_status","_queueEmissions","_emissionInterval","_queue","push","eventProps","didAnyEmit","forEach","event","didEmit","logger","on","off","index","splice","flush","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","includes","pause","queueEmissions","emissionInterval","resume","item","call","dequeueAsync","removeListeners","cleanup","listeners","map","addListener","removeListener","type","eventData","debugStatus","JSON","stringify","join","toString","currentTime","Date","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","static","opts","assign"],"mappings":"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"}