{"version":3,"file":"bundle.umd.min.js","sources":["esm/constants.js","esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["export const DEFAULT_IS_BUFFERED = false;\nexport const DEFAULT_BUFFER_CAPACITY = 5; // when buffered = true, this applies\nexport const DEFAULT_EMISSION_INTERVAL = 0; // when emission paused, intervald determines time between emissions\nexport const DEFAULT_QUEUE_EMISSION = true;\nexport const ALL_EVENTS = `__all-${Date.now()}`;\nexport const DEFAULT_CACHE_CAPACITY = 20;\nexport const DEFAULT_IS_CACHE = false;\nexport const EMIT_STATUS = {\n    PAUSED: \"0\",\n    EMITTING: \"1\",\n};\n//# sourceMappingURL=constants.js.map","/**\n * Event Properties\n */\nexport class EventProp {\n    name;\n    fn;\n    once;\n    options;\n    bucket;\n    timeoutID;\n    constructor(name, fn, once, options) {\n        this.name = name;\n        this.fn = fn;\n        this.once = once;\n        this.options = options;\n        if (options?.buffered) {\n            this.bucket = [];\n            this.timeoutID = undefined;\n        }\n    }\n}\n// Paused Event Properties\nexport class PausedEvtsProp {\n    name; // eventname\n    shouldQ; // should Queue events\n    interval; // emission interval\n    status;\n    constructor(name, status, shouldQ, interval) {\n        this.name = name;\n        this.status = status;\n        this.shouldQ = shouldQ;\n        this.interval = interval;\n    }\n    updateProps({ status, shouldQ, interval, }) {\n        if (status)\n            this.status = status;\n        if (shouldQ !== undefined)\n            this.shouldQ = shouldQ;\n        if (interval !== undefined)\n            this.interval = interval;\n    }\n    getProps() {\n        return {\n            status: this.status,\n            shouldQ: this.shouldQ,\n            interval: this.interval,\n            name: this.name,\n        };\n    }\n}\nexport function checkListenerOptionsEquality(obj1, obj2) {\n    if (obj1 === obj2)\n        return true;\n    if (!obj1 || !obj2)\n        return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    let key;\n    for (key in obj1) {\n        if (obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function getListenerIdx(events, listener, options) {\n    for (let i = 0; i < events.length; i++) {\n        if (events[i].fn === listener && checkListenerOptionsEquality(events[i].options, options)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function emitAfterTimeout(payload, ms) {\n    let timeoutId;\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\n        this.emit(payload.name, payload.data);\n        resolve(true);\n    }, ms))).finally(() => {\n        clearTimeout(timeoutId);\n    });\n}\n// shared debug state for BufferedEventEmitter\nexport let debugStatus = { emit: false, on: false, off: false };\nexport function updateDebugStatus(opts) {\n    debugStatus = { ...debugStatus, ...opts };\n}\nexport function logger(type, eventName, eventData) {\n    if ((type === \"emit\" && !debugStatus.emit) ||\n        (type === \"on\" && !debugStatus.on) ||\n        (type === \"off\" && !debugStatus.off))\n        return;\n    if (type === \"emit\") {\n        try {\n            eventData = JSON.stringify(eventData);\n        }\n        catch {\n            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\n        }\n    }\n    else if ([\"on\", \"off\"].includes(type) && typeof eventData === \"function\") {\n        eventData = eventData.toString();\n    }\n    const currentTime = new Date();\n    const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n    console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\n    console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\n    console.groupEnd();\n}\nexport class EventController {\n    flush() { }\n    off() { }\n}\nconst controls = new Map();\nexport function attachControls(control, eventProp) {\n    const eventProps = controls.get(control) || [];\n    eventProps.push(eventProp);\n    controls.set(control, eventProps);\n    control.off = () => {\n        eventProps.forEach((p) => {\n            this.off(p.name, p.fn, p.options);\n        });\n    };\n    control.flush = () => {\n        eventProps.forEach((p) => {\n            this.flush(p.name, p.fn, p.options);\n        });\n    };\n}\n//# sourceMappingURL=utils.js.map","import { DEFAULT_BUFFER_CAPACITY, ALL_EVENTS, DEFAULT_QUEUE_EMISSION, DEFAULT_EMISSION_INTERVAL, DEFAULT_IS_BUFFERED, DEFAULT_IS_CACHE, DEFAULT_CACHE_CAPACITY, EMIT_STATUS, } from \"./constants\";\nimport { EventProp, EventController, getListenerIdx, checkListenerOptionsEquality, emitAfterTimeout, logger, attachControls, PausedEvtsProp, debugStatus, updateDebugStatus } from \"./utils\";\nexport class BufferedEventEmitter {\n    _evts;\n    _opts;\n    _pEvtsConf; // stores paused events config\n    _pEvtsQ; // store paused events data\n    _cache;\n    constructor(options) {\n        this._evts = {};\n        this._opts = {\n            buffered: options?.buffered ?? DEFAULT_IS_BUFFERED,\n            bufferCapacity: options?.bufferCapacity ?? DEFAULT_BUFFER_CAPACITY,\n            logger: options?.logger ?? logger,\n            cache: options?.cache ?? DEFAULT_IS_CACHE,\n            cacheCapacity: options?.cacheCapacity ?? DEFAULT_CACHE_CAPACITY,\n        };\n        this._pEvtsConf = new Map([\n            [\n                ALL_EVENTS,\n                new PausedEvtsProp(ALL_EVENTS, EMIT_STATUS.EMITTING, DEFAULT_QUEUE_EMISSION, DEFAULT_EMISSION_INTERVAL),\n            ],\n        ]);\n        this._pEvtsQ = [];\n        this._cache = new Map();\n    }\n    emit(eventName, data) {\n        if (!this._evts[eventName] || this._evts[eventName].length === 0) {\n            return false;\n        }\n        const allEventsPaused = this._pEvtsConf.get(ALL_EVENTS)?.status === EMIT_STATUS.PAUSED;\n        const thisEventPaused = this._pEvtsConf.get(eventName)?.status === EMIT_STATUS.PAUSED;\n        if (allEventsPaused || thisEventPaused) {\n            if (this._pEvtsConf.get(ALL_EVENTS)?.shouldQ || this._pEvtsConf.get(eventName)?.shouldQ)\n                this._pEvtsQ.push({ name: eventName, data });\n            return false;\n        }\n        // collect events here which are !(once && emitted)\n        let eventProps = [];\n        let didAnyEmit = false;\n        // iterate through all registered events\n        this._evts[eventName].forEach((event) => {\n            let didEmit = false;\n            // buffered event handling\n            if (event?.options?.buffered) {\n                event?.bucket?.push(data);\n                const bufferCapacity = event?.options.bufferCapacity ?? this._opts.bufferCapacity;\n                if (event?.bucket && event.bucket.length >= bufferCapacity) {\n                    event.fn(event.bucket);\n                    addToCache.call(this, eventName, event.bucket);\n                    didEmit = true;\n                    didAnyEmit = true;\n                    this._opts.logger(\"emit\", eventName, event.bucket);\n                    event.bucket = [];\n                }\n            }\n            else {\n                // non-buffered event handling\n                event.fn(data);\n                addToCache.call(this, eventName, data);\n                didEmit = true;\n                didAnyEmit = true;\n                this._opts.logger(\"emit\", eventName, data);\n            }\n            // filter out once emitted events\n            if (!(event.once && didEmit)) {\n                eventProps.push(event);\n            }\n        });\n        this._evts[eventName] = eventProps;\n        return didAnyEmit;\n    }\n    /**\n     * Adds an event listener for given event name and options.\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\n     * @param eventName - Name of the event, listener will be added to\n     * @param listener - Function that will be called each time event is emitted\n     * @param options - Config options for listener\n     * @returns listener status if it was added or not\n     */\n    on(eventName, listener, options) {\n        if (!this._evts[eventName]) {\n            this._evts[eventName] = [];\n        }\n        // dedupe listeners\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index !== -1)\n            return false;\n        const eventProp = new EventProp(eventName, listener, false, options);\n        if (options?.control instanceof EventController) {\n            attachControls.call(this, options.control, eventProp);\n        }\n        this._evts[eventName].push(eventProp);\n        this._opts.logger(\"on\", eventName, listener);\n        return true;\n    }\n    /**\n     * Adds a one-time event listener for given event name and options.\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\n     * The first time event is triggered, this listener is invoked and then removed.\n     * @param eventName - Name of the event, listener will be added to\n     * @param listener - Function that will be called each time event is emitted\n     * @param options - Config options for listener\n     * @returns `true` if listener was added `false` otherwise.\n     */\n    once(eventName, listener, options) {\n        if (!this._evts[eventName]) {\n            this._evts[eventName] = [];\n        }\n        // dedupe listeners\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index !== -1)\n            return false;\n        const eventProp = new EventProp(eventName, listener, true, options);\n        if (options?.control instanceof EventController) {\n            attachControls.call(this, options.control, eventProp);\n        }\n        this._evts[eventName].push(eventProp);\n        this._opts.logger(\"on\", eventName, listener);\n        return true;\n    }\n    /**\n     * Removes an event listener previously registered with on() or addListener().\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\n     * @param eventName - Name of the event, listener was added to\n     * @param listener - Listener function to be removed from the registered listeners array\n     * @param options - Config options for listener\n     * @returns `true` if listener was removed `false` otherwise.\n     */\n    off(eventName, listener, options) {\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index === -1)\n            return false;\n        this._evts[eventName].splice(index, 1);\n        this._opts.logger(\"off\", eventName, listener);\n        return true;\n    }\n    flush(eventName, listener, options) {\n        let didAnyEmit = false;\n        let emittedOnceListenerIndexes = [];\n        this._evts[eventName].forEach((event, idx) => {\n            if (event?.options?.buffered && event?.bucket && event.bucket.length > 0) {\n                const matchesListenerFn = listener && listener === event.fn;\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\n                    (eventName && !listener && !options);\n                if (shouldFlush) {\n                    event.fn(event.bucket);\n                    addToCache.call(this, eventName, event.bucket);\n                    didAnyEmit = true;\n                    this._opts.logger(\"emit\", eventName, event.bucket);\n                    event.bucket = [];\n                    if (event.once)\n                        emittedOnceListenerIndexes.push(idx);\n                }\n            }\n        });\n        this._evts[eventName] = this._evts[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\n        return didAnyEmit;\n    }\n    /**\n     * Pause event emissions for all or provided event. Any subsequent event emissions will be swallowed or queued and\n     * their respective listeners will not be invoked until resume() is called.\n     * @param opts configure pausing using options\n     * @param opts.name name for event to be paused\n     * @param opts.queueEmissions if true, subsequent event emissions will be queued else swallowed\n     * @param opts.emissionInterval interval in ms for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\n     */\n    pause(opts) {\n        const queueEmissions = opts?.queueEmissions ?? DEFAULT_QUEUE_EMISSION;\n        const emissionInterval = opts?.emissionInterval ?? DEFAULT_EMISSION_INTERVAL;\n        if (typeof opts?.eventName === \"string\") {\n            this._pEvtsConf.set(opts?.eventName, new PausedEvtsProp(opts?.eventName, EMIT_STATUS.PAUSED, queueEmissions, emissionInterval));\n        }\n        else {\n            // delete all other paused events\n            if (this._pEvtsConf.size > 1)\n                this._pEvtsConf.clear();\n            this._pEvtsConf.set(ALL_EVENTS, new PausedEvtsProp(ALL_EVENTS, EMIT_STATUS.PAUSED, queueEmissions, emissionInterval));\n        }\n    }\n    /**\n     * Resumes event emission for all or provided event\n     * @param eventName: name for event to be resumed.\n     * @returns void or Promise depending on emission interval value.\n     */\n    resume(eventName) {\n        let pausedEvents = [];\n        let emissionInterval = DEFAULT_EMISSION_INTERVAL;\n        if (typeof eventName === \"string\") {\n            if (this._pEvtsConf.get(eventName)) {\n                const { shouldQ, status, interval } = this._pEvtsConf.get(eventName).getProps();\n                this._pEvtsConf.delete(eventName);\n                if (status === EMIT_STATUS.PAUSED) {\n                    if (shouldQ) {\n                        this._pEvtsQ = this._pEvtsQ.filter((o) => {\n                            if (o.name === eventName) {\n                                pausedEvents.push(o);\n                                return false;\n                            }\n                            else\n                                return true;\n                        });\n                        emissionInterval = interval;\n                    }\n                }\n            }\n        }\n        else {\n            if (this._pEvtsConf.size > 1) {\n                // use default values when eventName is not provided\n                emissionInterval = DEFAULT_EMISSION_INTERVAL;\n                pausedEvents = this._pEvtsQ;\n                this._pEvtsQ = [];\n            }\n            else if (this._pEvtsConf.get(ALL_EVENTS)) {\n                const { shouldQ, status, interval } = this._pEvtsConf.get(ALL_EVENTS).getProps();\n                this._pEvtsConf.clear();\n                if (status === EMIT_STATUS.PAUSED) {\n                    if (shouldQ) {\n                        pausedEvents = this._pEvtsQ;\n                        this._pEvtsQ = [];\n                        emissionInterval = interval;\n                    }\n                }\n            }\n        }\n        // async\n        if (emissionInterval > DEFAULT_EMISSION_INTERVAL) {\n            const dequeueAsync = async () => {\n                for (const item of pausedEvents) {\n                    await emitAfterTimeout.call(this, item, emissionInterval);\n                }\n            };\n            return dequeueAsync();\n            // sync\n        }\n        else {\n            pausedEvents.forEach(({ name, data }) => {\n                this.emit(name, data);\n            });\n        }\n    }\n    /**\n     * Remove all listeners for the provided event name.\n     * @param eventName - event name\n     * @returns `true` if any listener was removed for the event `false` otherwise.\n     */\n    offAll(eventName) {\n        if (eventName && this._evts[eventName]?.length > 0) {\n            delete this._evts[eventName];\n            this._pEvtsQ = this._pEvtsQ.filter((e) => e.name !== eventName);\n            this._pEvtsConf.delete(eventName);\n            this._cache.delete(eventName);\n            return true;\n        }\n        else\n            return false;\n    }\n    /**\n     * Removes all listeners and queued events for the instance.\n     */\n    cleanup() {\n        this._pEvtsConf.clear();\n        this._pEvtsQ = [];\n        this._cache.clear();\n        this._evts = {};\n    }\n    listeners(eventName) {\n        if (eventName === undefined) {\n            return this._evts;\n        }\n        else {\n            return this._evts[eventName].map((event) => event.fn);\n        }\n    }\n    /**\n     * Get cached data for particular event\n     * @param eventName - event name\n     * @returns cached event data\n     */\n    getCache(eventName) {\n        return this._cache.get(eventName) || [];\n    }\n    /**\n     * Enable debugging for all instances of the emitter\n     * @param opts\n     */\n    static enableDebug(opts) {\n        updateDebugStatus(opts);\n    }\n    /**\n     * Returns DebugStatus\n     */\n    static get debugStatus() {\n        return debugStatus;\n    }\n}\nBufferedEventEmitter.prototype.addListener = BufferedEventEmitter.prototype.on;\nBufferedEventEmitter.prototype.removeListener = BufferedEventEmitter.prototype.off;\nfunction addToCache(eventName, data) {\n    if (!this._opts.cache)\n        return;\n    const arr = this._cache.get(eventName);\n    const newArr = arr || [];\n    if (newArr.length >= this._opts.cacheCapacity) {\n        newArr.shift();\n    }\n    newArr.push(data);\n    this._cache.set(eventName, newArr);\n}\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["DEFAULT_QUEUE_EMISSION","ALL_EVENTS","Date","now","EMIT_STATUS","EventProp","name","fn","once","options","bucket","timeoutID","constructor","this","buffered","undefined","PausedEvtsProp","shouldQ","interval","status","updateProps","getProps","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","emitAfterTimeout","payload","ms","timeoutId","Promise","resolve","setTimeout","emit","data","finally","clearTimeout","debugStatus","on","off","logger","type","eventName","eventData","JSON","stringify","join","includes","toString","currentTime","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","EventController","flush","controls","Map","attachControls","control","eventProp","eventProps","get","push","set","forEach","p","BufferedEventEmitter","_evts","_opts","_pEvtsConf","_pEvtsQ","_cache","bufferCapacity","cache","cacheCapacity","allEventsPaused","thisEventPaused","didAnyEmit","event","didEmit","addToCache","call","index","splice","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","pause","opts","queueEmissions","emissionInterval","size","clear","resume","pausedEvents","delete","o","async","item","dequeueAsync","offAll","e","cleanup","listeners","map","getCache","enableDebug","updateDebugStatus","newArr","shift","prototype","addListener","removeListener"],"mappings":"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"}