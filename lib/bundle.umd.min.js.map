{"version":3,"file":"bundle.umd.min.js","sources":["esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["import { BufferedEventEmitter } from \"./bufferedEventEmitter\";\r\nexport class EventProp {\r\n    constructor(fn, once, options) {\r\n        this.fn = fn;\r\n        this.once = once;\r\n        this.options = options;\r\n        if (options === null || options === void 0 ? void 0 : options.buffered) {\r\n            this.bucket = [];\r\n            this.timeoutID = undefined;\r\n        }\r\n    }\r\n}\r\nexport function checkListenerOptionsEquality(obj1, obj2) {\r\n    if (!obj1 || !obj2)\r\n        return false;\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    let key;\r\n    for (key in obj1) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function getListenerIdx(events, listener, options) {\r\n    for (let i = 0; i < events.length; i++) {\r\n        if (events[i].fn === listener && checkListenerOptionsEquality(events[i].options, options)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexport function emitAfterTimeout(payload, ms) {\r\n    let timeoutId;\r\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\r\n        this.emit(payload.eventName, payload.data);\r\n        resolve(true);\r\n    }, ms))).finally(() => {\r\n        clearTimeout(timeoutId);\r\n    });\r\n}\r\nexport function logger(type, eventName, eventData) {\r\n    if ((type === \"emit\" && !BufferedEventEmitter.debugStatus.emit) ||\r\n        (type === \"on\" && !BufferedEventEmitter.debugStatus.on) ||\r\n        (type === \"off\" && !BufferedEventEmitter.debugStatus.off))\r\n        return;\r\n    if (type === \"emit\") {\r\n        try {\r\n            eventData = JSON.stringify(eventData);\r\n        }\r\n        catch (_a) {\r\n            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\r\n        }\r\n    }\r\n    else if ([\"on\", \"off\"].includes(type) && typeof eventData === \"function\") {\r\n        eventData = eventData.toString();\r\n    }\r\n    const currentTime = new Date();\r\n    const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\r\n    console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\r\n    console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\r\n    console.groupEnd();\r\n}\r\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { EventProp, getListenerIdx, checkListenerOptionsEquality, emitAfterTimeout, logger, } from \"./utils\";\r\n// when buffered\r\nconst DEFAULT_BUFFER_CAPACITY = 5;\r\n// when emission paused\r\nconst DEFAULT_EMISSION_INTERVAL = 0;\r\nexport class BufferedEventEmitter {\r\n    constructor(options) {\r\n        var _a, _b, _c;\r\n        this._events = {};\r\n        this._options = {\r\n            buffered: (_a = options === null || options === void 0 ? void 0 : options.buffered) !== null && _a !== void 0 ? _a : false,\r\n            bufferCapacity: (_b = options === null || options === void 0 ? void 0 : options.bufferCapacity) !== null && _b !== void 0 ? _b : DEFAULT_BUFFER_CAPACITY,\r\n            logger: (_c = options === null || options === void 0 ? void 0 : options.logger) !== null && _c !== void 0 ? _c : logger,\r\n        };\r\n        this._status = \"emitting\";\r\n        this._queueEmissions = true;\r\n        this._emissionInterval = DEFAULT_EMISSION_INTERVAL;\r\n        this._queue = [];\r\n    }\r\n    emit(eventName, data) {\r\n        if (!this._events[eventName] || this._events[eventName].length === 0) {\r\n            return false;\r\n        }\r\n        if (this._status === \"paused\") {\r\n            if (this._queueEmissions)\r\n                this._queue.push({ eventName, data });\r\n            return false;\r\n        }\r\n        // collect events here which are !(once && emitted)\r\n        let eventProps = [];\r\n        let didAnyEmit = false;\r\n        // iterate through all registered events\r\n        this._events[eventName].forEach((event) => {\r\n            var _a, _b;\r\n            let didEmit = false;\r\n            // buffered event handling\r\n            if (event.options.buffered) {\r\n                (_a = event === null || event === void 0 ? void 0 : event.bucket) === null || _a === void 0 ? void 0 : _a.push(data);\r\n                const bufferCapacity = (_b = event.options.bufferCapacity) !== null && _b !== void 0 ? _b : this._options.bufferCapacity;\r\n                if ((event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length >= bufferCapacity) {\r\n                    event.fn(event.bucket);\r\n                    didEmit = true;\r\n                    didAnyEmit = true;\r\n                    this._options.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                }\r\n            }\r\n            else {\r\n                // non-buffered event handling\r\n                event.fn(data);\r\n                didEmit = true;\r\n                didAnyEmit = true;\r\n                this._options.logger(\"emit\", eventName, data);\r\n            }\r\n            // filter out once emitted events\r\n            if (!(event.once && didEmit)) {\r\n                eventProps.push(event);\r\n            }\r\n        });\r\n        this._events[eventName] = eventProps;\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    on(eventName, listener, options = this._options) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        // dedupe listeners\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, false, options));\r\n        this._options.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Adds a one-time event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\r\n     * The first time event is triggered, this listener is invoked and then removed.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns `true` if listener was added `false` otherwise.\r\n     */\r\n    once(eventName, listener, options = this._options) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        // dedupe listeners\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, true, options));\r\n        this._options.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns `true` if listener was removed `false` otherwise.\r\n     */\r\n    off(eventName, listener, options = this._options) {\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index === -1)\r\n            return false;\r\n        this._events[eventName].splice(index, 1);\r\n        this._options.logger(\"off\", eventName, listener);\r\n        return true;\r\n    }\r\n    flush(eventName, listener, options) {\r\n        let didAnyEmit = false;\r\n        let emittedOnceListenerIndexes = [];\r\n        this._events[eventName].forEach((event, idx) => {\r\n            if (event.options.buffered && (event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length > 0) {\r\n                const matchesListenerFn = listener && listener === event.fn;\r\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\r\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\r\n                    (eventName && !listener && !options);\r\n                if (shouldFlush) {\r\n                    event.fn(event.bucket);\r\n                    didAnyEmit = true;\r\n                    this._options.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                    if (event.once)\r\n                        emittedOnceListenerIndexes.push(idx);\r\n                }\r\n            }\r\n        });\r\n        this._events[eventName] = this._events[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Pause event emissions. Any subsequent event emissions will be swallowed or queued and\r\n     * their respective listeners will not be invoked until resume() is called.\r\n     * @param queueEmissions if true, subsequent event emissions will be queued else swallowed\r\n     * @param emissionInterval interval in ms for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\r\n     */\r\n    pause(queueEmissions = true, emissionInterval = DEFAULT_EMISSION_INTERVAL) {\r\n        this._queueEmissions = queueEmissions;\r\n        this._emissionInterval = emissionInterval;\r\n        this._status = \"paused\";\r\n    }\r\n    /**\r\n     * Resumes event emission\r\n     * @returns void or Promise depending on emission interval value.\r\n     */\r\n    resume() {\r\n        this._status = \"emitting\";\r\n        if (this._queueEmissions) {\r\n            if (this._emissionInterval > DEFAULT_EMISSION_INTERVAL) {\r\n                const dequeueAsync = () => __awaiter(this, void 0, void 0, function* () {\r\n                    for (const item of this._queue) {\r\n                        yield emitAfterTimeout.call(this, item, this._emissionInterval);\r\n                    }\r\n                });\r\n                return dequeueAsync();\r\n            }\r\n            else {\r\n                this._queue.forEach(({ eventName, data }) => {\r\n                    this.emit(eventName, data);\r\n                });\r\n                this._queue = [];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided event name.\r\n     * @param eventName - event name\r\n     * @returns `true` if any listener was removed for the event `false` otherwise.\r\n     */\r\n    offAll(eventName) {\r\n        var _a;\r\n        if (eventName && ((_a = this._events[eventName]) === null || _a === void 0 ? void 0 : _a.length) > 0) {\r\n            delete this._events[eventName];\r\n            this._queue = this._queue.filter((e) => e.eventName !== eventName);\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    }\r\n    /**\r\n     * Removes all listeners and queued events for the instance.\r\n     */\r\n    cleanup() {\r\n        this._queue = [];\r\n        this._events = {};\r\n    }\r\n    listeners(eventName) {\r\n        if (eventName === undefined) {\r\n            return this._events;\r\n        }\r\n        else {\r\n            return this._events[eventName].map((event) => event.fn);\r\n        }\r\n    }\r\n    /**\r\n     * Enable debugging for all instances of the emitter\r\n     * @param opts\r\n     */\r\n    static enableDebug(opts) {\r\n        BufferedEventEmitter.debugStatus = Object.assign(Object.assign({}, BufferedEventEmitter.debugStatus), opts);\r\n    }\r\n}\r\nBufferedEventEmitter.debugStatus = { emit: false, on: false, off: false };\r\nBufferedEventEmitter.prototype.addListener = BufferedEventEmitter.prototype.on;\r\nBufferedEventEmitter.prototype.removeListener = BufferedEventEmitter.prototype.off;\r\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["EventProp","constructor","fn","once","options","this","buffered","bucket","timeoutID","undefined","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","emitAfterTimeout","payload","ms","timeoutId","Promise","resolve","setTimeout","emit","eventName","data","finally","clearTimeout","logger","type","eventData","BufferedEventEmitter","debugStatus","on","off","JSON","stringify","_a","join","includes","toString","currentTime","Date","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","_b","_c","_events","_options","bufferCapacity","_status","_queueEmissions","_emissionInterval","_queue","push","eventProps","didAnyEmit","forEach","event","didEmit","index","splice","flush","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","pause","queueEmissions","emissionInterval","resume","item","call","dequeueAsync","offAll","cleanup","listeners","map","static","opts","assign","prototype","addListener","removeListener"],"mappings":"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"}