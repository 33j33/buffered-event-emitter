const t=!0,s=`__all-${Date.now()}`,e="0",i="1";class n{name;fn;once;options;bucket;timeoutID;constructor(t,s,e,i){this.name=t,this.fn=s,this.once=e,this.options=i,i?.buffered&&(this.bucket=[],this.timeoutID=void 0)}}class o{name;shouldQ;interval;status;constructor(t,s,e,i){this.name=t,this.status=s,this.shouldQ=e,this.interval=i}updateProps({status:t,shouldQ:s,interval:e}){t&&(this.status=t),void 0!==s&&(this.shouldQ=s),void 0!==e&&(this.interval=e)}getProps(){return{status:this.status,shouldQ:this.shouldQ,interval:this.interval,name:this.name}}}function h(t,s){if(t===s)return!0;if(!t||!s)return!1;const e=Object.keys(t),i=Object.keys(s);if(e.length!==i.length)return!1;let n;for(n in t)if(t[n]!==s[n])return!1;return!0}function c(t,s,e){for(let i=0;i<t.length;i++)if(t[i].fn===s&&h(t[i].options,e))return i;return-1}function r(t,s){let e;return new Promise((i=>e=setTimeout((()=>{this.emit(t.name,t.data),i(!0)}),s))).finally((()=>{clearTimeout(e)}))}let f={emit:!1,on:!1,off:!1};function a(t,s,e){if("emit"===t&&!f.emit||"on"===t&&!f.on||"off"===t&&!f.off)return;if("emit"===t)try{e=JSON.stringify(e)}catch{e=`Object with the following keys failed to stringify: ${Object.keys(e).join(",")}`}else["on","off"].includes(t)&&"function"==typeof e&&(e=e.toString());const i=new Date,n=`${i.getHours()}:${i.getMinutes()}:${i.getSeconds()}.${i.getMilliseconds()}`;console.groupCollapsed(`%c[Event Type: ${t} | Event Name: ${s} | ${n}]`,"color: blue; font-size: 12px"),console.log(`%c[Event Data: ${e}}]`,"color: #AD5D4E; font-size: 11px"),console.groupEnd()}class u{flush(){}off(){}}const l=new Map;function p(t,s){const e=l.get(t)||[];e.push(s),l.set(t,e),t.off=()=>{e.forEach((t=>{this.off(t.name,t.fn,t.options)}))},t.flush=()=>{e.forEach((t=>{this.flush(t.name,t.fn,t.options)}))}}class v{_evts;_opts;_pEvtsConf;_pEvtsQ;_cache;constructor(e){this._evts={},this._opts={buffered:e?.buffered??false,bufferCapacity:e?.bufferCapacity??5,logger:e?.logger??a,cache:e?.cache??false,cacheCapacity:e?.cacheCapacity??20},this._pEvtsConf=new Map([[s,new o(s,i,t,0)]]),this._pEvtsQ=[],this._cache=new Map}emit(t,i){if(!this._evts[t]||0===this._evts[t].length)return!1;const n=this._pEvtsConf.get(s)?.status===e,o=this._pEvtsConf.get(t)?.status===e;if(n||o)return(this._pEvtsConf.get(s)?.shouldQ||this._pEvtsConf.get(t)?.shouldQ)&&this._pEvtsQ.push({name:t,data:i}),!1;let h=[],c=!1;return this._evts[t].forEach((s=>{let e=!1;if(s?.options?.buffered){s?.bucket?.push(i);const n=s?.options.bufferCapacity??this._opts.bufferCapacity;s?.bucket&&s.bucket.length>=n&&(s.fn(s.bucket),_.call(this,t,s.bucket),e=!0,c=!0,this._opts.logger("emit",t,s.bucket),s.bucket=[])}else s.fn(i),_.call(this,t,i),e=!0,c=!0,this._opts.logger("emit",t,i);s.once&&e||h.push(s)})),this._evts[t]=h,c}on(t,s,e){if(this._evts[t]||(this._evts[t]=[]),-1!==c(this._evts[t],s,e))return!1;const i=new n(t,s,!1,e);return e?.control instanceof u&&p.call(this,e.control,i),this._evts[t].push(i),this._opts.logger("on",t,s),!0}once(t,s,e){if(this._evts[t]||(this._evts[t]=[]),-1!==c(this._evts[t],s,e))return!1;const i=new n(t,s,!0,e);return e?.control instanceof u&&p.call(this,e.control,i),this._evts[t].push(i),this._opts.logger("on",t,s),!0}off(t,s,e){let i=c(this._evts[t],s,e);return-1!==i&&(this._evts[t].splice(i,1),this._opts.logger("off",t,s),!0)}flush(t,s,e){let i=!1,n=[];return this._evts[t].forEach(((o,c)=>{if(o?.options?.buffered&&o?.bucket&&o.bucket.length>0){const r=s&&s===o.fn,f=e&&h(e,o.options);(t&&r&&f||t&&!s&&!e)&&(o.fn(o.bucket),_.call(this,t,o.bucket),i=!0,this._opts.logger("emit",t,o.bucket),o.bucket=[],o.once&&n.push(c))}})),this._evts[t]=this._evts[t].filter(((t,s)=>!n.includes(s))),i}pause(i){const n=i?.queueEmissions??t,h=i?.emissionInterval??0;"string"==typeof i?.eventName?this._pEvtsConf.set(i?.eventName,new o(i?.eventName,e,n,h)):(this._pEvtsConf.size>1&&this._pEvtsConf.clear(),this._pEvtsConf.set(s,new o(s,e,n,h)))}resume(t){let i=[],n=0;if("string"==typeof t){if(this._pEvtsConf.get(t)){const{shouldQ:s,status:o,interval:h}=this._pEvtsConf.get(t).getProps();this._pEvtsConf.delete(t),o===e&&s&&(this._pEvtsQ=this._pEvtsQ.filter((s=>s.name!==t||(i.push(s),!1))),n=h)}}else if(this._pEvtsConf.size>1)n=0,i=this._pEvtsQ,this._pEvtsQ=[];else if(this._pEvtsConf.get(s)){const{shouldQ:t,status:o,interval:h}=this._pEvtsConf.get(s).getProps();this._pEvtsConf.clear(),o===e&&t&&(i=this._pEvtsQ,this._pEvtsQ=[],n=h)}if(n>0){return(async()=>{for(const t of i)await r.call(this,t,n)})()}i.forEach((({name:t,data:s})=>{this.emit(t,s)}))}offAll(t){return!!(t&&this._evts[t]?.length>0)&&(delete this._evts[t],this._pEvtsQ=this._pEvtsQ.filter((s=>s.name!==t)),this._pEvtsConf.delete(t),this._cache.delete(t),!0)}cleanup(){this._pEvtsConf.clear(),this._pEvtsQ=[],this._cache.clear(),this._evts={}}listeners(t){return void 0===t?this._evts:this._evts[t].map((t=>t.fn))}getCache(t){return this._cache.get(t)||[]}static enableDebug(t){!function(t){f={...f,...t}}(t)}static get debugStatus(){return f}}function _(t,s){if(!this._opts.cache)return;const e=this._cache.get(t)||[];e.length>=this._opts.cacheCapacity&&e.shift(),e.push(s),this._cache.set(t,e)}v.prototype.addListener=v.prototype.on,v.prototype.removeListener=v.prototype.off;export{v as BufferedEventEmitter,u as EventController};
//# sourceMappingURL=bundle.esm.min.mjs.map
