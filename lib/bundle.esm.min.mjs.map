{"version":3,"file":"bundle.esm.min.mjs","sources":["esm/bufferedEventEmitter.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _BufferedEventEmitter_instances, _BufferedEventEmitter_emitAfterTimeout;\r\nclass EventProp {\r\n    constructor(fn, once, options) {\r\n        this.fn = fn;\r\n        this.once = once;\r\n        this.options = options;\r\n        if (options === null || options === void 0 ? void 0 : options.buffered) {\r\n            this.bucket = [];\r\n            this.timeoutID = undefined;\r\n        }\r\n    }\r\n}\r\nexport class BufferedEventEmitter {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        _BufferedEventEmitter_instances.add(this);\r\n        this._events = {};\r\n        this._defaultListenerOptions = {\r\n            buffered: (_a = options === null || options === void 0 ? void 0 : options.buffered) !== null && _a !== void 0 ? _a : false,\r\n            bufferCapacity: (_b = options === null || options === void 0 ? void 0 : options.bufferCapacity) !== null && _b !== void 0 ? _b : 5,\r\n        };\r\n        this._status = \"emitting\";\r\n        this._shouldQueueEmissions = true;\r\n        this._emissionInterval = 0;\r\n        this._queue = [];\r\n    }\r\n    emit(eventName, data) {\r\n        if (!this._events[eventName] || this._events[eventName].length === 0) {\r\n            return false;\r\n        }\r\n        if (this._status === \"paused\") {\r\n            if (this._shouldQueueEmissions)\r\n                this._queue.push({ eventName, data });\r\n            return false;\r\n        }\r\n        // collect events here which are !(once && emitted)\r\n        let eventProps = [];\r\n        let didAnyEmit = false;\r\n        // iterate through all registered events\r\n        this._events[eventName].forEach((event) => {\r\n            var _a, _b;\r\n            let didEmit = false;\r\n            // buffered event handling\r\n            if (event.options.buffered) {\r\n                (_a = event === null || event === void 0 ? void 0 : event.bucket) === null || _a === void 0 ? void 0 : _a.push(data);\r\n                const bufferCapacity = (_b = event.options.bufferCapacity) !== null && _b !== void 0 ? _b : this._defaultListenerOptions.bufferCapacity;\r\n                if ((event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length >= bufferCapacity) {\r\n                    event.fn(event.bucket);\r\n                    didEmit = true;\r\n                    didAnyEmit = true;\r\n                    this.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                }\r\n            }\r\n            else {\r\n                // non-buffered event handling\r\n                event.fn(data);\r\n                didEmit = true;\r\n                didAnyEmit = true;\r\n                this.logger(\"emit\", eventName, data);\r\n            }\r\n            // filter out once emitted events\r\n            if (!(event.once && didEmit)) {\r\n                eventProps.push(event);\r\n            }\r\n        });\r\n        this._events[eventName] = eventProps;\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of listener and options is already for the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    on(eventName, listener, options = {}) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, false, options));\r\n        this.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Adds a one-time event listener for given event name and options.\r\n     * If the combination of listener and options is already for the given event name the listener is not added a second time.\r\n     * The next time event is triggered, this listener is invoked and then removed.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    once(eventName, listener, options = {}) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, true, options));\r\n        this.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was removed or not\r\n     */\r\n    removeListener(eventName, listener, options = {}) {\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index === -1)\r\n            return false;\r\n        this._events[eventName].splice(index, 1);\r\n        this.logger(\"off\", eventName, listener);\r\n        return true;\r\n    }\r\n    flush(eventName, listener, options) {\r\n        let didAnyEmit = false;\r\n        let emittedOnceListenerIndexes = [];\r\n        this._events[eventName].forEach((event, idx) => {\r\n            if (event.options.buffered && (event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length > 0) {\r\n                const matchesListenerFn = listener && listener === event.fn;\r\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\r\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\r\n                    (eventName && !listener && !options);\r\n                if (shouldFlush) {\r\n                    event.fn(event.bucket);\r\n                    didAnyEmit = true;\r\n                    this.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                    if (event.once)\r\n                        emittedOnceListenerIndexes.push(idx);\r\n                }\r\n            }\r\n        });\r\n        this._events[eventName] = this._events[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Pause event emissions. Any subsequent event emissions will be stopped or queued and\r\n     * their respective listeners will not be invoked until resume() is called.\r\n     * @param queueEmissions if true, subsequent event emissions will be queued else stopped\r\n     * @param emissionInterval interval for dequeueing queued events. if interval is 0, the events are dequeued in synchronously\r\n     */\r\n    pause(queueEmissions = true, emissionInterval = 0) {\r\n        this._shouldQueueEmissions = queueEmissions;\r\n        this._emissionInterval = emissionInterval;\r\n        this._status = \"paused\";\r\n    }\r\n    /**\r\n     * Resumes event emission\r\n     * @returns void or Promise depending on emission interval value.\r\n     */\r\n    resume() {\r\n        this._status = \"emitting\";\r\n        if (this._shouldQueueEmissions) {\r\n            if (this._emissionInterval > 0) {\r\n                const dequeueAsync = () => __awaiter(this, void 0, void 0, function* () {\r\n                    console.log(\"queue\", this._queue);\r\n                    for (const item of this._queue) {\r\n                        yield __classPrivateFieldGet(this, _BufferedEventEmitter_instances, \"m\", _BufferedEventEmitter_emitAfterTimeout).call(this, item, this._emissionInterval);\r\n                    }\r\n                });\r\n                return dequeueAsync();\r\n            }\r\n            else {\r\n                this._queue.forEach(({ eventName, data }) => {\r\n                    this.emit(eventName, data);\r\n                });\r\n                this._queue = [];\r\n            }\r\n        }\r\n    }\r\n    listeners(eventName) {\r\n        if (eventName === undefined) {\r\n            return this._events;\r\n        }\r\n        else {\r\n            return this._events[eventName].map((event) => event.fn);\r\n        }\r\n    }\r\n    // aliases\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of listener and options is already for the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    addListener(eventName, listener, options = {}) {\r\n        return this.on(eventName, listener, options);\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was removed or not\r\n     */\r\n    off(eventName, listener, options = {}) {\r\n        return this.removeListener(eventName, listener, options);\r\n    }\r\n    logger(type, eventName, eventData) {\r\n        if ((type === \"emit\" && !BufferedEventEmitter.debugEnabled.emit) ||\r\n            (type === \"on\" && !BufferedEventEmitter.debugEnabled.on) ||\r\n            (type === \"off\" && !BufferedEventEmitter.debugEnabled.off))\r\n            return;\r\n        if (type === \"emit\") {\r\n            try {\r\n                eventData = JSON.stringify(eventData);\r\n            }\r\n            catch (_a) {\r\n                eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\r\n            }\r\n        }\r\n        else if (type === \"on\" && typeof eventData === \"function\") {\r\n            eventData = eventData.toString();\r\n        }\r\n        const currentTime = new Date();\r\n        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\r\n        console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\r\n        console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\r\n        console.groupEnd();\r\n    }\r\n    static enableDebug(opts) {\r\n        this.debugEnabled = Object.assign(Object.assign({}, this.debugEnabled), opts);\r\n    }\r\n}\r\n_BufferedEventEmitter_instances = new WeakSet(), _BufferedEventEmitter_emitAfterTimeout = function _BufferedEventEmitter_emitAfterTimeout(payload, ms) {\r\n    let timeoutId;\r\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\r\n        this.emit(payload.eventName, payload.data);\r\n        resolve(true);\r\n    }, ms))).finally(() => {\r\n        clearTimeout(timeoutId);\r\n    });\r\n};\r\nBufferedEventEmitter.debugEnabled = { emit: false, on: false, off: false };\r\nfunction checkListenerOptionsEquality(obj1, obj2) {\r\n    if (!obj1 || !obj2)\r\n        return false;\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    let key;\r\n    for (key in obj1) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getListenerIdx(events, listener, options) {\r\n    for (let i = 0; i < events.length; i++) {\r\n        if (events[i].fn === listener &&\r\n            checkListenerOptionsEquality(events[i].options, options)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["_BufferedEventEmitter_instances","_BufferedEventEmitter_emitAfterTimeout","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","get","EventProp","constructor","fn","once","options","this","buffered","bucket","timeoutID","undefined","BufferedEventEmitter","_a","_b","add","_events","_defaultListenerOptions","bufferCapacity","_status","_shouldQueueEmissions","_emissionInterval","_queue","emit","eventName","data","length","push","eventProps","didAnyEmit","forEach","event","didEmit","logger","on","listener","getListenerIdx","removeListener","index","splice","flush","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","checkListenerOptionsEquality","filter","_","includes","pause","queueEmissions","emissionInterval","resume","console","log","item","dequeueAsync","listeners","map","addListener","off","type","eventData","debugEnabled","JSON","stringify","Object","keys","join","toString","currentTime","Date","logTime","getHours","getMinutes","getSeconds","getMilliseconds","groupCollapsed","groupEnd","static","opts","assign","obj1","obj2","keys1","keys2","key","events","i","WeakSet","payload","ms","timeoutId","setTimeout","finally","clearTimeout"],"mappings":"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"}