{"version":3,"file":"bundle.esm.min.mjs","sources":["esm/constants.js","esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["export const DEFAULT_IS_BUFFERED = false;\nexport const DEFAULT_BUFFER_CAPACITY = 5; // when buffered = true, this applies\nexport const DEFAULT_EMISSION_INTERVAL = 0; // when emission paused, intervald determines time between emissions\nexport const DEFAULT_QUEUE_EMISSION = true;\nexport const ALL_EVENTS = `__all-${Date.now()}`;\nexport const DEFAULT_CACHE_CAPACITY = 20;\nexport const DEFAULT_IS_CACHE = false;\nexport const EMIT_STATUS = {\n    PAUSED: \"0\",\n    EMITTING: \"1\",\n};\n//# sourceMappingURL=constants.js.map","/**\n * Event Properties\n */\nexport class EventProp {\n    constructor(name, fn, once, options) {\n        this.name = name;\n        this.fn = fn;\n        this.once = once;\n        this.options = options;\n        if (options === null || options === void 0 ? void 0 : options.buffered) {\n            this.bucket = [];\n            this.timeoutID = undefined;\n        }\n    }\n}\n// Paused Event Properties\nexport class PausedEvtsProp {\n    constructor(name, status, shouldQ, interval) {\n        this.name = name;\n        this.status = status;\n        this.shouldQ = shouldQ;\n        this.interval = interval;\n    }\n    updateProps({ status, shouldQ, interval, }) {\n        if (status)\n            this.status = status;\n        if (shouldQ !== undefined)\n            this.shouldQ = shouldQ;\n        if (interval !== undefined)\n            this.interval = interval;\n    }\n    getProps() {\n        return {\n            status: this.status,\n            shouldQ: this.shouldQ,\n            interval: this.interval,\n            name: this.name,\n        };\n    }\n}\nexport function checkListenerOptionsEquality(obj1, obj2) {\n    if (obj1 === obj2)\n        return true;\n    if (!obj1 || !obj2)\n        return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    let key;\n    for (key in obj1) {\n        if (obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function getListenerIdx(events, listener, options) {\n    for (let i = 0; i < events.length; i++) {\n        if (events[i].fn === listener && checkListenerOptionsEquality(events[i].options, options)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function emitAfterTimeout(payload, ms) {\n    let timeoutId;\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\n        this.emit(payload.name, payload.data);\n        resolve(true);\n    }, ms))).finally(() => {\n        clearTimeout(timeoutId);\n    });\n}\n// shared debug state for BufferedEventEmitter\nexport let debugStatus = { emit: false, on: false, off: false };\nexport function updateDebugStatus(opts) {\n    debugStatus = Object.assign(Object.assign({}, debugStatus), opts);\n}\nexport function logger(type, eventName, eventData) {\n    if ((type === \"emit\" && !debugStatus.emit) ||\n        (type === \"on\" && !debugStatus.on) ||\n        (type === \"off\" && !debugStatus.off))\n        return;\n    if (type === \"emit\") {\n        try {\n            eventData = JSON.stringify(eventData);\n        }\n        catch (_a) {\n            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\n        }\n    }\n    else if ([\"on\", \"off\"].includes(type) && typeof eventData === \"function\") {\n        eventData = eventData.toString();\n    }\n    const currentTime = new Date();\n    const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n    console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\n    console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\n    console.groupEnd();\n}\nexport class EventController {\n    flush() { }\n    off() { }\n}\nconst controls = new Map();\nexport function attachControls(control, eventProp) {\n    const eventProps = controls.get(control) || [];\n    eventProps.push(eventProp);\n    controls.set(control, eventProps);\n    control.off = () => {\n        eventProps.forEach((p) => {\n            this.off(p.name, p.fn, p.options);\n        });\n    };\n    control.flush = () => {\n        eventProps.forEach((p) => {\n            this.flush(p.name, p.fn, p.options);\n        });\n    };\n}\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DEFAULT_BUFFER_CAPACITY, ALL_EVENTS, DEFAULT_QUEUE_EMISSION, DEFAULT_EMISSION_INTERVAL, DEFAULT_IS_BUFFERED, DEFAULT_IS_CACHE, DEFAULT_CACHE_CAPACITY, EMIT_STATUS, } from \"./constants\";\nimport { EventProp, EventController, getListenerIdx, checkListenerOptionsEquality, emitAfterTimeout, logger, attachControls, PausedEvtsProp, debugStatus, updateDebugStatus } from \"./utils\";\nexport class BufferedEventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d, _e;\n        this._evts = {};\n        this._opts = {\n            buffered: (_a = options === null || options === void 0 ? void 0 : options.buffered) !== null && _a !== void 0 ? _a : DEFAULT_IS_BUFFERED,\n            bufferCapacity: (_b = options === null || options === void 0 ? void 0 : options.bufferCapacity) !== null && _b !== void 0 ? _b : DEFAULT_BUFFER_CAPACITY,\n            logger: (_c = options === null || options === void 0 ? void 0 : options.logger) !== null && _c !== void 0 ? _c : logger,\n            cache: (_d = options === null || options === void 0 ? void 0 : options.cache) !== null && _d !== void 0 ? _d : DEFAULT_IS_CACHE,\n            cacheCapacity: (_e = options === null || options === void 0 ? void 0 : options.cacheCapacity) !== null && _e !== void 0 ? _e : DEFAULT_CACHE_CAPACITY,\n        };\n        this._pEvtsConf = new Map([\n            [\n                ALL_EVENTS,\n                new PausedEvtsProp(ALL_EVENTS, EMIT_STATUS.EMITTING, DEFAULT_QUEUE_EMISSION, DEFAULT_EMISSION_INTERVAL),\n            ],\n        ]);\n        this._pEvtsQ = [];\n        this._cache = new Map();\n    }\n    emit(eventName, data) {\n        var _a, _b, _c, _d;\n        if (!this._evts[eventName] || this._evts[eventName].length === 0) {\n            return false;\n        }\n        const allEventsPaused = ((_a = this._pEvtsConf.get(ALL_EVENTS)) === null || _a === void 0 ? void 0 : _a.status) === EMIT_STATUS.PAUSED;\n        const thisEventPaused = ((_b = this._pEvtsConf.get(eventName)) === null || _b === void 0 ? void 0 : _b.status) === EMIT_STATUS.PAUSED;\n        if (allEventsPaused || thisEventPaused) {\n            if (((_c = this._pEvtsConf.get(ALL_EVENTS)) === null || _c === void 0 ? void 0 : _c.shouldQ) || ((_d = this._pEvtsConf.get(eventName)) === null || _d === void 0 ? void 0 : _d.shouldQ))\n                this._pEvtsQ.push({ name: eventName, data });\n            return false;\n        }\n        // collect events here which are !(once && emitted)\n        let eventProps = [];\n        let didAnyEmit = false;\n        // iterate through all registered events\n        this._evts[eventName].forEach((event) => {\n            var _a, _b, _c;\n            let didEmit = false;\n            // buffered event handling\n            if ((_a = event === null || event === void 0 ? void 0 : event.options) === null || _a === void 0 ? void 0 : _a.buffered) {\n                (_b = event === null || event === void 0 ? void 0 : event.bucket) === null || _b === void 0 ? void 0 : _b.push(data);\n                const bufferCapacity = (_c = event === null || event === void 0 ? void 0 : event.options.bufferCapacity) !== null && _c !== void 0 ? _c : this._opts.bufferCapacity;\n                if ((event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length >= bufferCapacity) {\n                    event.fn(event.bucket);\n                    addToCache.call(this, eventName, event.bucket);\n                    didEmit = true;\n                    didAnyEmit = true;\n                    this._opts.logger(\"emit\", eventName, event.bucket);\n                    event.bucket = [];\n                }\n            }\n            else {\n                // non-buffered event handling\n                event.fn(data);\n                addToCache.call(this, eventName, data);\n                didEmit = true;\n                didAnyEmit = true;\n                this._opts.logger(\"emit\", eventName, data);\n            }\n            // filter out once emitted events\n            if (!(event.once && didEmit)) {\n                eventProps.push(event);\n            }\n        });\n        this._evts[eventName] = eventProps;\n        return didAnyEmit;\n    }\n    /**\n     * Adds an event listener for given event name and options.\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\n     * @param eventName - Name of the event, listener will be added to\n     * @param listener - Function that will be called each time event is emitted\n     * @param options - Config options for listener\n     * @returns listener status if it was added or not\n     */\n    on(eventName, listener, options) {\n        if (!this._evts[eventName]) {\n            this._evts[eventName] = [];\n        }\n        // dedupe listeners\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index !== -1)\n            return false;\n        const eventProp = new EventProp(eventName, listener, false, options);\n        if ((options === null || options === void 0 ? void 0 : options.control) instanceof EventController) {\n            attachControls.call(this, options.control, eventProp);\n        }\n        this._evts[eventName].push(eventProp);\n        this._opts.logger(\"on\", eventName, listener);\n        return true;\n    }\n    /**\n     * Adds a one-time event listener for given event name and options.\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\n     * The first time event is triggered, this listener is invoked and then removed.\n     * @param eventName - Name of the event, listener will be added to\n     * @param listener - Function that will be called each time event is emitted\n     * @param options - Config options for listener\n     * @returns `true` if listener was added `false` otherwise.\n     */\n    once(eventName, listener, options) {\n        if (!this._evts[eventName]) {\n            this._evts[eventName] = [];\n        }\n        // dedupe listeners\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index !== -1)\n            return false;\n        const eventProp = new EventProp(eventName, listener, true, options);\n        if ((options === null || options === void 0 ? void 0 : options.control) instanceof EventController) {\n            attachControls.call(this, options.control, eventProp);\n        }\n        this._evts[eventName].push(eventProp);\n        this._opts.logger(\"on\", eventName, listener);\n        return true;\n    }\n    /**\n     * Removes an event listener previously registered with on() or addListener().\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\n     * @param eventName - Name of the event, listener was added to\n     * @param listener - Listener function to be removed from the registered listeners array\n     * @param options - Config options for listener\n     * @returns `true` if listener was removed `false` otherwise.\n     */\n    off(eventName, listener, options) {\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index === -1)\n            return false;\n        this._evts[eventName].splice(index, 1);\n        this._opts.logger(\"off\", eventName, listener);\n        return true;\n    }\n    flush(eventName, listener, options) {\n        let didAnyEmit = false;\n        let emittedOnceListenerIndexes = [];\n        this._evts[eventName].forEach((event, idx) => {\n            var _a;\n            if (((_a = event === null || event === void 0 ? void 0 : event.options) === null || _a === void 0 ? void 0 : _a.buffered) && (event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length > 0) {\n                const matchesListenerFn = listener && listener === event.fn;\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\n                    (eventName && !listener && !options);\n                if (shouldFlush) {\n                    event.fn(event.bucket);\n                    addToCache.call(this, eventName, event.bucket);\n                    didAnyEmit = true;\n                    this._opts.logger(\"emit\", eventName, event.bucket);\n                    event.bucket = [];\n                    if (event.once)\n                        emittedOnceListenerIndexes.push(idx);\n                }\n            }\n        });\n        this._evts[eventName] = this._evts[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\n        return didAnyEmit;\n    }\n    /**\n     * Pause event emissions for all or provided event. Any subsequent event emissions will be swallowed or queued and\n     * their respective listeners will not be invoked until resume() is called.\n     * @param opts configure pausing using options\n     * @param opts.name name for event to be paused\n     * @param opts.queueEmissions if true, subsequent event emissions will be queued else swallowed\n     * @param opts.emissionInterval interval in ms for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\n     */\n    pause(opts) {\n        var _a, _b;\n        const queueEmissions = (_a = opts === null || opts === void 0 ? void 0 : opts.queueEmissions) !== null && _a !== void 0 ? _a : DEFAULT_QUEUE_EMISSION;\n        const emissionInterval = (_b = opts === null || opts === void 0 ? void 0 : opts.emissionInterval) !== null && _b !== void 0 ? _b : DEFAULT_EMISSION_INTERVAL;\n        if (typeof (opts === null || opts === void 0 ? void 0 : opts.eventName) === \"string\") {\n            this._pEvtsConf.set(opts === null || opts === void 0 ? void 0 : opts.eventName, new PausedEvtsProp(opts === null || opts === void 0 ? void 0 : opts.eventName, EMIT_STATUS.PAUSED, queueEmissions, emissionInterval));\n        }\n        else {\n            // delete all other paused events\n            if (this._pEvtsConf.size > 1)\n                this._pEvtsConf.clear();\n            this._pEvtsConf.set(ALL_EVENTS, new PausedEvtsProp(ALL_EVENTS, EMIT_STATUS.PAUSED, queueEmissions, emissionInterval));\n        }\n    }\n    /**\n     * Resumes event emission for all or provided event\n     * @param eventName: name for event to be resumed.\n     * @returns void or Promise depending on emission interval value.\n     */\n    resume(eventName) {\n        let pausedEvents = [];\n        let emissionInterval = DEFAULT_EMISSION_INTERVAL;\n        if (typeof eventName === \"string\") {\n            if (this._pEvtsConf.get(eventName)) {\n                const { shouldQ, status, interval } = this._pEvtsConf.get(eventName).getProps();\n                this._pEvtsConf.delete(eventName);\n                if (status === EMIT_STATUS.PAUSED) {\n                    if (shouldQ) {\n                        this._pEvtsQ = this._pEvtsQ.filter((o) => {\n                            if (o.name === eventName) {\n                                pausedEvents.push(o);\n                                return false;\n                            }\n                            else\n                                return true;\n                        });\n                        emissionInterval = interval;\n                    }\n                }\n            }\n        }\n        else {\n            if (this._pEvtsConf.size > 1) {\n                // use default values when eventName is not provided\n                emissionInterval = DEFAULT_EMISSION_INTERVAL;\n                pausedEvents = this._pEvtsQ;\n                this._pEvtsQ = [];\n            }\n            else if (this._pEvtsConf.get(ALL_EVENTS)) {\n                const { shouldQ, status, interval } = this._pEvtsConf.get(ALL_EVENTS).getProps();\n                this._pEvtsConf.clear();\n                if (status === EMIT_STATUS.PAUSED) {\n                    if (shouldQ) {\n                        pausedEvents = this._pEvtsQ;\n                        this._pEvtsQ = [];\n                        emissionInterval = interval;\n                    }\n                }\n            }\n        }\n        // async\n        if (emissionInterval > DEFAULT_EMISSION_INTERVAL) {\n            const dequeueAsync = () => __awaiter(this, void 0, void 0, function* () {\n                for (const item of pausedEvents) {\n                    yield emitAfterTimeout.call(this, item, emissionInterval);\n                }\n            });\n            return dequeueAsync();\n            // sync\n        }\n        else {\n            pausedEvents.forEach(({ name, data }) => {\n                this.emit(name, data);\n            });\n        }\n    }\n    /**\n     * Remove all listeners for the provided event name.\n     * @param eventName - event name\n     * @returns `true` if any listener was removed for the event `false` otherwise.\n     */\n    offAll(eventName) {\n        var _a;\n        if (eventName && ((_a = this._evts[eventName]) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n            delete this._evts[eventName];\n            this._pEvtsQ = this._pEvtsQ.filter((e) => e.name !== eventName);\n            this._pEvtsConf.delete(eventName);\n            this._cache.delete(eventName);\n            return true;\n        }\n        else\n            return false;\n    }\n    /**\n     * Removes all listeners and queued events for the instance.\n     */\n    cleanup() {\n        this._pEvtsConf.clear();\n        this._pEvtsQ = [];\n        this._cache.clear();\n        this._evts = {};\n    }\n    listeners(eventName) {\n        if (eventName === undefined) {\n            return this._evts;\n        }\n        else {\n            return this._evts[eventName].map((event) => event.fn);\n        }\n    }\n    /**\n     * Get cached data for particular event\n     * @param eventName - event name\n     * @returns cached event data\n     */\n    getCache(eventName) {\n        return this._cache.get(eventName) || [];\n    }\n    /**\n     * Enable debugging for all instances of the emitter\n     * @param opts\n     */\n    static enableDebug(opts) {\n        updateDebugStatus(opts);\n    }\n    /**\n     * Returns DebugStatus\n     */\n    static get debugStatus() {\n        return debugStatus;\n    }\n}\nBufferedEventEmitter.prototype.addListener = BufferedEventEmitter.prototype.on;\nBufferedEventEmitter.prototype.removeListener = BufferedEventEmitter.prototype.off;\nfunction addToCache(eventName, data) {\n    if (!this._opts.cache)\n        return;\n    const arr = this._cache.get(eventName);\n    const newArr = arr || [];\n    if (newArr.length >= this._opts.cacheCapacity) {\n        newArr.shift();\n    }\n    newArr.push(data);\n    this._cache.set(eventName, newArr);\n}\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["DEFAULT_QUEUE_EMISSION","ALL_EVENTS","Date","now","EMIT_STATUS","EventProp","constructor","name","fn","once","options","this","buffered","bucket","timeoutID","undefined","PausedEvtsProp","status","shouldQ","interval","updateProps","getProps","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","emitAfterTimeout","payload","ms","timeoutId","Promise","resolve","setTimeout","emit","data","finally","clearTimeout","debugStatus","on","off","logger","type","eventName","eventData","JSON","stringify","_a","join","includes","toString","currentTime","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","EventController","flush","controls","Map","attachControls","control","eventProp","eventProps","get","push","set","forEach","p","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","BufferedEventEmitter","_b","_c","_d","_e","_evts","_opts","bufferCapacity","cache","cacheCapacity","_pEvtsConf","_pEvtsQ","_cache","allEventsPaused","thisEventPaused","didAnyEmit","event","didEmit","addToCache","call","index","splice","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","pause","opts","queueEmissions","emissionInterval","size","clear","resume","pausedEvents","delete","o","item","dequeueAsync","offAll","cleanup","listeners","map","getCache","enableDebug","assign","updateDebugStatus","newArr","shift","prototype","addListener","removeListener"],"mappings":"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"}