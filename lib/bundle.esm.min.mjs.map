{"version":3,"file":"bundle.esm.min.mjs","sources":["esm/constants.js","esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["export const DEFAULT_IS_BUFFERED = false;\nexport const DEFAULT_BUFFER_CAPACITY = 5; // when buffered = true, this applies\nexport const DEFAULT_EMISSION_INTERVAL = 0; // when emission paused, intervald determines time between emissions\nexport const DEFAULT_QUEUE_EMISSION = true;\nexport const ALL_EVENTS = `__all-${Date.now()}`;\nexport const DEFAULT_CACHE_CAPACITY = 20;\nexport const DEFAULT_IS_CACHE = false;\nexport const EMIT_STATUS = {\n    PAUSED: \"0\",\n    EMITTING: \"1\",\n};\nexport const DEFAULT_BUFFER_INACTIVITY_TIMEOUT = 0; // inactivity timeout default (in ms). 0 means “no auto-flush”.\n//# sourceMappingURL=constants.js.map","/**\n * Event Properties\n */\nexport class EventProp {\n    name;\n    fn;\n    once;\n    options;\n    bucket;\n    bufferInactivityTimeoutId;\n    constructor(name, fn, once, options) {\n        this.name = name;\n        this.fn = fn;\n        this.once = once;\n        this.options = options;\n        if (options?.buffered) {\n            this.bucket = [];\n            this.bufferInactivityTimeoutId = undefined;\n        }\n    }\n}\n// Paused Event Properties\nexport class PausedEvtsProp {\n    name; // eventname\n    shouldQ; // should Queue events\n    interval; // emission interval\n    status;\n    constructor(name, status, shouldQ, interval) {\n        this.name = name;\n        this.status = status;\n        this.shouldQ = shouldQ;\n        this.interval = interval;\n    }\n    updateProps({ status, shouldQ, interval, }) {\n        if (status)\n            this.status = status;\n        if (shouldQ !== undefined)\n            this.shouldQ = shouldQ;\n        if (interval !== undefined)\n            this.interval = interval;\n    }\n    getProps() {\n        return {\n            status: this.status,\n            shouldQ: this.shouldQ,\n            interval: this.interval,\n            name: this.name,\n        };\n    }\n}\nexport function checkListenerOptionsEquality(obj1, obj2) {\n    if (obj1 === obj2)\n        return true;\n    if (!obj1 || !obj2)\n        return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    let key;\n    for (key in obj1) {\n        if (obj1[key] !== obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function getListenerIdx(events, listener, options) {\n    for (let i = 0; i < events.length; i++) {\n        if (events[i].fn === listener && checkListenerOptionsEquality(events[i].options, options)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function emitAfterTimeout(payload, ms) {\n    let timeoutId;\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\n        this.emit(payload.name, payload.data);\n        resolve(true);\n    }, ms))).finally(() => {\n        clearTimeout(timeoutId);\n    });\n}\n// shared debug state for BufferedEventEmitter\nexport let debugStatus = { emit: false, on: false, off: false };\nexport function updateDebugStatus(opts) {\n    debugStatus = { ...debugStatus, ...opts };\n}\nexport function logger(type, eventName, eventData) {\n    if ((type === \"emit\" && !debugStatus.emit) ||\n        (type === \"on\" && !debugStatus.on) ||\n        (type === \"off\" && !debugStatus.off))\n        return;\n    if (type === \"emit\") {\n        try {\n            eventData = JSON.stringify(eventData);\n        }\n        catch {\n            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\n        }\n    }\n    else if ([\"on\", \"off\"].includes(type) && typeof eventData === \"function\") {\n        eventData = eventData.toString();\n    }\n    const currentTime = new Date();\n    const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n    console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\n    console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\n    console.groupEnd();\n}\nexport class EventController {\n    flush() { }\n    off() { }\n}\nconst controls = new Map();\nexport function attachControls(control, eventProp) {\n    const eventProps = controls.get(control) || [];\n    eventProps.push(eventProp);\n    controls.set(control, eventProps);\n    control.off = () => {\n        eventProps.forEach((p) => {\n            this.off(p.name, p.fn, p.options);\n        });\n    };\n    control.flush = () => {\n        eventProps.forEach((p) => {\n            this.flush(p.name, p.fn, p.options);\n        });\n    };\n}\n//# sourceMappingURL=utils.js.map","import { DEFAULT_BUFFER_CAPACITY, ALL_EVENTS, DEFAULT_QUEUE_EMISSION, DEFAULT_EMISSION_INTERVAL, DEFAULT_IS_BUFFERED, DEFAULT_IS_CACHE, DEFAULT_CACHE_CAPACITY, EMIT_STATUS, DEFAULT_BUFFER_INACTIVITY_TIMEOUT, } from \"./constants\";\nimport { EventProp, EventController, getListenerIdx, checkListenerOptionsEquality, emitAfterTimeout, logger, attachControls, PausedEvtsProp, debugStatus, updateDebugStatus } from \"./utils\";\nexport class BufferedEventEmitter {\n    _evts;\n    _opts;\n    _pEvtsConf; // stores paused events config\n    _pEvtsQ; // store paused events data\n    _cache;\n    constructor(options) {\n        this._evts = {};\n        this._opts = {\n            buffered: options?.buffered ?? DEFAULT_IS_BUFFERED,\n            bufferCapacity: options?.bufferCapacity ?? DEFAULT_BUFFER_CAPACITY,\n            bufferInactivityTimeout: options?.bufferInactivityTimeout ?? DEFAULT_BUFFER_INACTIVITY_TIMEOUT,\n            logger: options?.logger ?? logger,\n            cache: options?.cache ?? DEFAULT_IS_CACHE,\n            cacheCapacity: options?.cacheCapacity ?? DEFAULT_CACHE_CAPACITY\n        };\n        // Initialize pause/resume configuration with default \"emitting\" state for all events.\n        // This ensures ALL_EVENTS always exists for global pause/resume operations and \n        // eliminates null checks when determining if events should be paused or queued.\n        this._pEvtsConf = new Map([\n            [\n                ALL_EVENTS,\n                new PausedEvtsProp(ALL_EVENTS, EMIT_STATUS.EMITTING, DEFAULT_QUEUE_EMISSION, DEFAULT_EMISSION_INTERVAL),\n            ],\n        ]);\n        this._pEvtsQ = [];\n        this._cache = new Map();\n    }\n    emit(eventName, data) {\n        if (!this._evts[eventName] || this._evts[eventName].length === 0) {\n            return false;\n        }\n        const allEventsPaused = this._pEvtsConf.get(ALL_EVENTS)?.status === EMIT_STATUS.PAUSED;\n        const thisEventPaused = this._pEvtsConf.get(eventName)?.status === EMIT_STATUS.PAUSED;\n        if (allEventsPaused || thisEventPaused) {\n            if (this._pEvtsConf.get(ALL_EVENTS)?.shouldQ || this._pEvtsConf.get(eventName)?.shouldQ)\n                this._pEvtsQ.push({ name: eventName, data });\n            return false;\n        }\n        // collect listeners for event which are not 'once' and not invoked\n        let remainingListeners = [];\n        // flag to store if any event emission invokes a listener\n        let didInvokeAnyListener = false;\n        // iterate through all registered events\n        this._evts[eventName].forEach((event) => {\n            let didInvokeCurrentListener = false;\n            // buffered event handling\n            if (event?.options?.buffered) {\n                event?.bucket?.push(data);\n                const bufferCapacity = event?.options.bufferCapacity ?? this._opts.bufferCapacity;\n                if (event?.bucket && event.bucket.length >= bufferCapacity) {\n                    // new event emissions should clear the timeout\n                    if (event.bufferInactivityTimeoutId) {\n                        clearTimeout(event.bufferInactivityTimeoutId);\n                        event.bufferInactivityTimeoutId = undefined;\n                    }\n                    event.fn(event.bucket);\n                    addToCache.call(this, eventName, event.bucket);\n                    didInvokeCurrentListener = true;\n                    didInvokeAnyListener = true;\n                    this._opts.logger(\"emit\", eventName, event.bucket);\n                    event.bucket = [];\n                }\n                else if (event?.bucket && event.bucket.length > 0) { // bucket less than bufferCapacity\n                    const timeoutDuration = event?.options?.bufferInactivityTimeout ?? this._opts.bufferInactivityTimeout;\n                    // create inactivity timeout when bufferInactivityTimeout is set in listener or default config to something greater than 0ms\n                    if (timeoutDuration > 0) {\n                        // Clear existing timeout before creating new one\n                        if (event.bufferInactivityTimeoutId) {\n                            clearTimeout(event.bufferInactivityTimeoutId);\n                            event.bufferInactivityTimeoutId = undefined;\n                        }\n                        event.bufferInactivityTimeoutId = setTimeout(() => {\n                            if (event?.bucket && event.bucket.length) {\n                                event.fn(event.bucket);\n                                addToCache.call(this, eventName, event.bucket);\n                                this._opts.logger(\"emit\", eventName, event.bucket);\n                                event.bucket = [];\n                            }\n                            event.bufferInactivityTimeoutId = undefined;\n                        }, timeoutDuration);\n                    }\n                }\n            }\n            else {\n                // non-buffered event handling\n                event.fn(data);\n                addToCache.call(this, eventName, data);\n                didInvokeCurrentListener = true;\n                didInvokeAnyListener = true;\n                this._opts.logger(\"emit\", eventName, data);\n            }\n            // filter out once emitted listeners\n            if (!(event.once && didInvokeCurrentListener)) {\n                remainingListeners.push(event);\n            }\n        });\n        this._evts[eventName] = remainingListeners;\n        return didInvokeAnyListener;\n    }\n    /**\n     * Adds an event listener for given event name and options.\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\n     * @param eventName - Name of the event, listener will be added to\n     * @param listener - Function that will be called each time event is emitted\n     * @param options - Config options for listener\n     * @returns listener status if it was added or not\n     */\n    on(eventName, listener, options) {\n        if (!this._evts[eventName]) {\n            this._evts[eventName] = [];\n        }\n        // dedupe listeners\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index !== -1)\n            return false;\n        const eventProp = new EventProp(eventName, listener, false, options);\n        if (options?.control instanceof EventController) {\n            attachControls.call(this, options.control, eventProp);\n        }\n        this._evts[eventName].push(eventProp);\n        this._opts.logger(\"on\", eventName, listener);\n        return true;\n    }\n    /**\n     * Adds a one-time event listener for given event name and options.\n     * If the combination of event name, listener and options is already present for the given event name the listener is not added a second time.\n     * The first time event is triggered, this listener is invoked and then removed.\n     * @param eventName - Name of the event, listener will be added to\n     * @param listener - Function that will be called each time event is emitted\n     * @param options - Config options for listener\n     * @returns `true` if listener was added `false` otherwise.\n     */\n    once(eventName, listener, options) {\n        if (!this._evts[eventName]) {\n            this._evts[eventName] = [];\n        }\n        // dedupe listeners\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index !== -1)\n            return false;\n        const eventProp = new EventProp(eventName, listener, true, options);\n        if (options?.control instanceof EventController) {\n            attachControls.call(this, options.control, eventProp);\n        }\n        this._evts[eventName].push(eventProp);\n        this._opts.logger(\"on\", eventName, listener);\n        return true;\n    }\n    /**\n     * Removes an event listener previously registered with on() or addListener().\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\n     * @param eventName - Name of the event, listener was added to\n     * @param listener - Listener function to be removed from the registered listeners array\n     * @param options - Config options for listener\n     * @returns `true` if listener was removed `false` otherwise.\n     */\n    off(eventName, listener, options) {\n        let index = getListenerIdx(this._evts[eventName], listener, options);\n        if (index === -1)\n            return false;\n        const [event] = this._evts[eventName].splice(index, 1);\n        if (event.bufferInactivityTimeoutId) {\n            clearTimeout(event.bufferInactivityTimeoutId);\n            event.bufferInactivityTimeoutId = undefined;\n        }\n        this._opts.logger(\"off\", eventName, listener);\n        return true;\n    }\n    flush(eventName, listener, options) {\n        let didAnyEmit = false;\n        let emittedOnceListenerIndexes = [];\n        this._evts[eventName].forEach((event, idx) => {\n            if (event?.options?.buffered && event?.bucket && event.bucket.length > 0) {\n                const matchesListenerFn = listener && listener === event.fn;\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\n                    (eventName && !listener && !options);\n                if (shouldFlush) {\n                    // clear timeout if defined\n                    if (event.bufferInactivityTimeoutId) {\n                        clearTimeout(event.bufferInactivityTimeoutId);\n                        event.bufferInactivityTimeoutId = undefined;\n                    }\n                    event.fn(event.bucket);\n                    addToCache.call(this, eventName, event.bucket);\n                    didAnyEmit = true;\n                    this._opts.logger(\"emit\", eventName, event.bucket);\n                    event.bucket = [];\n                    if (event.once)\n                        emittedOnceListenerIndexes.push(idx);\n                }\n            }\n        });\n        this._evts[eventName] = this._evts[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\n        return didAnyEmit;\n    }\n    /**\n     * Pause event emissions for all or provided event. Any subsequent event emissions will be swallowed or queued and\n     * their respective listeners will not be invoked until resume() is called.\n     * @param opts configure pausing using options\n     * @param opts.name name for event to be paused\n     * @param opts.queueEmissions if true, subsequent event emissions will be queued else swallowed\n     * @param opts.emissionInterval interval in ms for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\n     */\n    pause(opts) {\n        const queueEmissions = opts?.queueEmissions ?? DEFAULT_QUEUE_EMISSION;\n        const emissionInterval = opts?.emissionInterval ?? DEFAULT_EMISSION_INTERVAL;\n        if (typeof opts?.eventName === \"string\") {\n            this._pEvtsConf.set(opts?.eventName, new PausedEvtsProp(opts?.eventName, EMIT_STATUS.PAUSED, queueEmissions, emissionInterval));\n        }\n        else {\n            // delete all other paused events\n            if (this._pEvtsConf.size > 1)\n                this._pEvtsConf.clear();\n            this._pEvtsConf.set(ALL_EVENTS, new PausedEvtsProp(ALL_EVENTS, EMIT_STATUS.PAUSED, queueEmissions, emissionInterval));\n        }\n    }\n    /**\n     * Resumes event emission for all or provided event\n     * @param eventName: name for event to be resumed.\n     * @returns void or Promise depending on emission interval value.\n     */\n    resume(eventName) {\n        let pausedEvents = [];\n        let emissionInterval = DEFAULT_EMISSION_INTERVAL;\n        if (typeof eventName === \"string\") {\n            if (this._pEvtsConf.get(eventName)) {\n                const { shouldQ, status, interval } = this._pEvtsConf.get(eventName).getProps();\n                this._pEvtsConf.delete(eventName);\n                if (status === EMIT_STATUS.PAUSED) {\n                    if (shouldQ) {\n                        this._pEvtsQ = this._pEvtsQ.filter((o) => {\n                            if (o.name === eventName) {\n                                pausedEvents.push(o);\n                                return false;\n                            }\n                            else\n                                return true;\n                        });\n                        emissionInterval = interval;\n                    }\n                }\n            }\n        }\n        else {\n            if (this._pEvtsConf.size > 1) {\n                // use default values when eventName is not provided\n                emissionInterval = DEFAULT_EMISSION_INTERVAL;\n                pausedEvents = this._pEvtsQ;\n                this._pEvtsQ = [];\n            }\n            else if (this._pEvtsConf.get(ALL_EVENTS)) {\n                const { shouldQ, status, interval } = this._pEvtsConf.get(ALL_EVENTS).getProps();\n                this._pEvtsConf.clear();\n                if (status === EMIT_STATUS.PAUSED) {\n                    if (shouldQ) {\n                        pausedEvents = this._pEvtsQ;\n                        this._pEvtsQ = [];\n                        emissionInterval = interval;\n                    }\n                }\n            }\n        }\n        // async\n        if (emissionInterval > DEFAULT_EMISSION_INTERVAL) {\n            const dequeueAsync = async () => {\n                for (const item of pausedEvents) {\n                    await emitAfterTimeout.call(this, item, emissionInterval);\n                }\n            };\n            return dequeueAsync();\n            // sync\n        }\n        else {\n            pausedEvents.forEach(({ name, data }) => {\n                this.emit(name, data);\n            });\n        }\n    }\n    /**\n     * Remove all listeners for the provided event name.\n     * @param eventName - event name\n     * @returns `true` if any listener was removed for the event `false` otherwise.\n     */\n    offAll(eventName) {\n        if (eventName && this._evts[eventName]?.length > 0) {\n            const events = this._evts[eventName];\n            events.forEach(event => {\n                if (event.bufferInactivityTimeoutId) {\n                    clearTimeout(event.bufferInactivityTimeoutId);\n                    event.bufferInactivityTimeoutId = undefined;\n                }\n            });\n            delete this._evts[eventName];\n            this._pEvtsQ = this._pEvtsQ.filter((e) => e.name !== eventName);\n            this._pEvtsConf.delete(eventName);\n            this._cache.delete(eventName);\n            return true;\n        }\n        else\n            return false;\n    }\n    /**\n     * Removes all listeners and queued events for the instance.\n     */\n    cleanup() {\n        this._pEvtsConf.clear();\n        this._pEvtsQ = [];\n        this._cache.clear();\n        Object.values(this._evts).forEach(events => {\n            events.forEach(event => {\n                if (event.bufferInactivityTimeoutId) {\n                    clearTimeout(event.bufferInactivityTimeoutId);\n                    event.bufferInactivityTimeoutId = undefined;\n                }\n            });\n        });\n        this._evts = {};\n    }\n    listeners(eventName) {\n        if (eventName === undefined) {\n            return this._evts;\n        }\n        else {\n            return this._evts[eventName].map((event) => event.fn);\n        }\n    }\n    /**\n     * Get cached data for particular event\n     * @param eventName - event name\n     * @returns cached event data\n     */\n    getCache(eventName) {\n        return this._cache.get(eventName) || [];\n    }\n    /**\n     * Enable debugging for all instances of the emitter\n     * @param opts\n     */\n    static enableDebug(opts) {\n        updateDebugStatus(opts);\n    }\n    /**\n     * Returns DebugStatus\n     */\n    static get debugStatus() {\n        return debugStatus;\n    }\n}\nBufferedEventEmitter.prototype.addListener = BufferedEventEmitter.prototype.on;\nBufferedEventEmitter.prototype.removeListener = BufferedEventEmitter.prototype.off;\nfunction addToCache(eventName, data) {\n    if (!this._opts.cache)\n        return;\n    const arr = this._cache.get(eventName);\n    const newArr = arr || [];\n    if (newArr.length >= this._opts.cacheCapacity) {\n        newArr.shift();\n    }\n    newArr.push(data);\n    this._cache.set(eventName, newArr);\n}\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["DEFAULT_QUEUE_EMISSION","ALL_EVENTS","Date","now","EMIT_STATUS","EventProp","name","fn","once","options","bucket","bufferInactivityTimeoutId","constructor","this","buffered","undefined","PausedEvtsProp","shouldQ","interval","status","updateProps","getProps","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","emitAfterTimeout","payload","ms","timeoutId","Promise","resolve","setTimeout","emit","data","finally","clearTimeout","debugStatus","on","off","logger","type","eventName","eventData","JSON","stringify","join","includes","toString","currentTime","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","EventController","flush","controls","Map","attachControls","control","eventProp","eventProps","get","push","set","forEach","p","BufferedEventEmitter","_evts","_opts","_pEvtsConf","_pEvtsQ","_cache","bufferCapacity","bufferInactivityTimeout","cache","cacheCapacity","allEventsPaused","thisEventPaused","remainingListeners","didInvokeAnyListener","event","didInvokeCurrentListener","addToCache","call","timeoutDuration","index","splice","didAnyEmit","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","pause","opts","queueEmissions","emissionInterval","size","clear","resume","pausedEvents","delete","o","async","item","dequeueAsync","offAll","e","cleanup","values","listeners","map","getCache","enableDebug","updateDebugStatus","newArr","shift","prototype","addListener","removeListener"],"mappings":"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"}