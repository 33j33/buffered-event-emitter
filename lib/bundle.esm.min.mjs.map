{"version":3,"file":"bundle.esm.min.mjs","sources":["esm/utils.js","esm/bufferedEventEmitter.js"],"sourcesContent":["export class EventProp {\r\n    constructor(fn, once, options) {\r\n        this.fn = fn;\r\n        this.once = once;\r\n        this.options = options;\r\n        if (options === null || options === void 0 ? void 0 : options.buffered) {\r\n            this.bucket = [];\r\n            this.timeoutID = undefined;\r\n        }\r\n    }\r\n}\r\nexport function checkListenerOptionsEquality(obj1, obj2) {\r\n    if (!obj1 || !obj2)\r\n        return false;\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    let key;\r\n    for (key in obj1) {\r\n        if (obj1[key] !== obj2[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function getListenerIdx(events, listener, options) {\r\n    for (let i = 0; i < events.length; i++) {\r\n        if (events[i].fn === listener &&\r\n            checkListenerOptionsEquality(events[i].options, options)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _BufferedEventEmitter_instances, _BufferedEventEmitter_emitAfterTimeout;\r\nimport { EventProp, getListenerIdx, checkListenerOptionsEquality, } from \"./utils\";\r\nexport class BufferedEventEmitter {\r\n    constructor(options) {\r\n        var _a, _b;\r\n        _BufferedEventEmitter_instances.add(this);\r\n        this._events = {};\r\n        this._defaultListenerOptions = {\r\n            buffered: (_a = options === null || options === void 0 ? void 0 : options.buffered) !== null && _a !== void 0 ? _a : false,\r\n            bufferCapacity: (_b = options === null || options === void 0 ? void 0 : options.bufferCapacity) !== null && _b !== void 0 ? _b : 5,\r\n        };\r\n        this._status = \"emitting\";\r\n        this._shouldQueueEmissions = true;\r\n        this._emissionInterval = 0;\r\n        this._queue = [];\r\n    }\r\n    emit(eventName, data) {\r\n        if (!this._events[eventName] || this._events[eventName].length === 0) {\r\n            return false;\r\n        }\r\n        if (this._status === \"paused\") {\r\n            if (this._shouldQueueEmissions)\r\n                this._queue.push({ eventName, data });\r\n            return false;\r\n        }\r\n        // collect events here which are !(once && emitted)\r\n        let eventProps = [];\r\n        let didAnyEmit = false;\r\n        // iterate through all registered events\r\n        this._events[eventName].forEach((event) => {\r\n            var _a, _b;\r\n            let didEmit = false;\r\n            // buffered event handling\r\n            if (event.options.buffered) {\r\n                (_a = event === null || event === void 0 ? void 0 : event.bucket) === null || _a === void 0 ? void 0 : _a.push(data);\r\n                const bufferCapacity = (_b = event.options.bufferCapacity) !== null && _b !== void 0 ? _b : this._defaultListenerOptions.bufferCapacity;\r\n                if ((event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length >= bufferCapacity) {\r\n                    event.fn(event.bucket);\r\n                    didEmit = true;\r\n                    didAnyEmit = true;\r\n                    this.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                }\r\n            }\r\n            else {\r\n                // non-buffered event handling\r\n                event.fn(data);\r\n                didEmit = true;\r\n                didAnyEmit = true;\r\n                this.logger(\"emit\", eventName, data);\r\n            }\r\n            // filter out once emitted events\r\n            if (!(event.once && didEmit)) {\r\n                eventProps.push(event);\r\n            }\r\n        });\r\n        this._events[eventName] = eventProps;\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    on(eventName, listener, options = this._defaultListenerOptions) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, false, options));\r\n        this.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Adds a one-time event listener for given event name and options.\r\n     * If the combination of event name, listener and options is already present the given event name the listener is not added a second time.\r\n     * The first time event is triggered, this listener is invoked and then removed.\r\n     * @param eventName - Name of the event, listener will be added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    once(eventName, listener, options = this._defaultListenerOptions) {\r\n        if (!this._events[eventName]) {\r\n            this._events[eventName] = [];\r\n        }\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index !== -1)\r\n            return false;\r\n        this._events[eventName].push(new EventProp(listener, true, options));\r\n        this.logger(\"on\", eventName, listener);\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was removed or not\r\n     */\r\n    off(eventName, listener, options = this._defaultListenerOptions) {\r\n        let index = getListenerIdx(this._events[eventName], listener, options);\r\n        if (index === -1)\r\n            return false;\r\n        this._events[eventName].splice(index, 1);\r\n        this.logger(\"off\", eventName, listener);\r\n        return true;\r\n    }\r\n    flush(eventName, listener, options) {\r\n        let didAnyEmit = false;\r\n        let emittedOnceListenerIndexes = [];\r\n        this._events[eventName].forEach((event, idx) => {\r\n            if (event.options.buffered && (event === null || event === void 0 ? void 0 : event.bucket) && event.bucket.length > 0) {\r\n                const matchesListenerFn = listener && listener === event.fn;\r\n                const matchesOptions = options && checkListenerOptionsEquality(options, event.options);\r\n                const shouldFlush = (eventName && matchesListenerFn && matchesOptions) ||\r\n                    (eventName && !listener && !options);\r\n                if (shouldFlush) {\r\n                    event.fn(event.bucket);\r\n                    didAnyEmit = true;\r\n                    this.logger(\"emit\", eventName, event.bucket);\r\n                    event.bucket = [];\r\n                    if (event.once)\r\n                        emittedOnceListenerIndexes.push(idx);\r\n                }\r\n            }\r\n        });\r\n        this._events[eventName] = this._events[eventName].filter((_, idx) => !emittedOnceListenerIndexes.includes(idx));\r\n        return didAnyEmit;\r\n    }\r\n    /**\r\n     * Pause event emissions. Any subsequent event emissions will be swallowed or queued and\r\n     * their respective listeners will not be invoked until resume() is called.\r\n     * @param queueEmissions if true, subsequent event emissions will be queued else swallowed\r\n     * @param emissionInterval interval for dequeueing queued events. if interval is 0, the events are dequeued synchronously else asynchronously but in order\r\n     */\r\n    pause(queueEmissions = true, emissionInterval = 0) {\r\n        this._shouldQueueEmissions = queueEmissions;\r\n        this._emissionInterval = emissionInterval;\r\n        this._status = \"paused\";\r\n    }\r\n    /**\r\n     * Resumes event emission\r\n     * @returns void or Promise depending on emission interval value.\r\n     */\r\n    resume() {\r\n        this._status = \"emitting\";\r\n        if (this._shouldQueueEmissions) {\r\n            if (this._emissionInterval > 0) {\r\n                const dequeueAsync = () => __awaiter(this, void 0, void 0, function* () {\r\n                    for (const item of this._queue) {\r\n                        yield __classPrivateFieldGet(this, _BufferedEventEmitter_instances, \"m\", _BufferedEventEmitter_emitAfterTimeout).call(this, item, this._emissionInterval);\r\n                    }\r\n                });\r\n                return dequeueAsync();\r\n            }\r\n            else {\r\n                this._queue.forEach(({ eventName, data }) => {\r\n                    this.emit(eventName, data);\r\n                });\r\n                this._queue = [];\r\n            }\r\n        }\r\n    }\r\n    cleanup(eventName) {\r\n        var _a;\r\n        if (eventName && ((_a = this._events[eventName]) === null || _a === void 0 ? void 0 : _a.length) > 0) {\r\n            this._events[eventName] = [];\r\n            this._queue = this._queue.filter((e) => e.eventName !== eventName);\r\n        }\r\n        else {\r\n            this._queue = [];\r\n            this._events = {};\r\n        }\r\n    }\r\n    listeners(eventName) {\r\n        if (eventName === undefined) {\r\n            return this._events;\r\n        }\r\n        else {\r\n            return this._events[eventName].map((event) => event.fn);\r\n        }\r\n    }\r\n    // aliases\r\n    /**\r\n     * Adds an event listener for given event name and options.\r\n     * If the combination of listener and options is already present the given event name the listener is not added a second time.\r\n     * @param eventName - Name of the event, listener was added to\r\n     * @param listener - Function that will be called each time event is emitted\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was added or not\r\n     */\r\n    addListener(eventName, listener, options = this._defaultListenerOptions) {\r\n        return this.on(eventName, listener, options);\r\n    }\r\n    /**\r\n     * Removes an event listener previously registered with on() or addListener().\r\n     * The event listener to be removed is identified using a combination of the event name, the event listener function itself, and provided options\r\n     * @param eventName  Name of the event, listener will be added to\r\n     * @param listener - Listener function to be removed from the registered listeners array\r\n     * @param options - Config options for listener\r\n     * @returns listener status if it was removed or not\r\n     */\r\n    removeListener(eventName, listener, options = this._defaultListenerOptions) {\r\n        return this.off(eventName, listener, options);\r\n    }\r\n    logger(type, eventName, eventData) {\r\n        if ((type === \"emit\" && !BufferedEventEmitter.debugEnabled.emit) ||\r\n            (type === \"on\" && !BufferedEventEmitter.debugEnabled.on) ||\r\n            (type === \"off\" && !BufferedEventEmitter.debugEnabled.off))\r\n            return;\r\n        if (type === \"emit\") {\r\n            try {\r\n                eventData = JSON.stringify(eventData);\r\n            }\r\n            catch (_a) {\r\n                eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(\",\")}`;\r\n            }\r\n        }\r\n        else if (type === \"on\" && typeof eventData === \"function\") {\r\n            eventData = eventData.toString();\r\n        }\r\n        const currentTime = new Date();\r\n        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\r\n        console.groupCollapsed(`%c[Event Type: ${type} | Event Name: ${eventName} | ${logTime}]`, \"color: blue; font-size: 12px\");\r\n        console.log(`%c[Event Data: ${eventData}}]`, \"color: #AD5D4E; font-size: 11px\");\r\n        console.groupEnd();\r\n    }\r\n    /**\r\n     * Enable debugging for all instances of the emitter\r\n     * @param opts\r\n     */\r\n    static enableDebug(opts) {\r\n        BufferedEventEmitter.debugEnabled = Object.assign(Object.assign({}, BufferedEventEmitter.debugEnabled), opts);\r\n    }\r\n}\r\n_BufferedEventEmitter_instances = new WeakSet(), _BufferedEventEmitter_emitAfterTimeout = function _BufferedEventEmitter_emitAfterTimeout(payload, ms) {\r\n    let timeoutId;\r\n    return new Promise((resolve) => (timeoutId = setTimeout(() => {\r\n        this.emit(payload.eventName, payload.data);\r\n        resolve(true);\r\n    }, ms))).finally(() => {\r\n        clearTimeout(timeoutId);\r\n    });\r\n};\r\nBufferedEventEmitter.debugEnabled = { emit: false, on: false, off: false };\r\n//# sourceMappingURL=bufferedEventEmitter.js.map"],"names":["EventProp","constructor","fn","once","options","this","buffered","bucket","timeoutID","undefined","checkListenerOptionsEquality","obj1","obj2","keys1","Object","keys","keys2","length","key","getListenerIdx","events","listener","i","_BufferedEventEmitter_instances","_BufferedEventEmitter_emitAfterTimeout","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","get","BufferedEventEmitter","_a","_b","add","_events","_defaultListenerOptions","bufferCapacity","_status","_shouldQueueEmissions","_emissionInterval","_queue","emit","eventName","data","push","eventProps","didAnyEmit","forEach","event","didEmit","logger","on","off","index","splice","flush","emittedOnceListenerIndexes","idx","matchesListenerFn","matchesOptions","filter","_","includes","pause","queueEmissions","emissionInterval","resume","item","dequeueAsync","cleanup","listeners","map","addListener","removeListener","type","eventData","debugEnabled","JSON","stringify","join","toString","currentTime","Date","logTime","getHours","getMinutes","getSeconds","getMilliseconds","console","groupCollapsed","log","groupEnd","static","opts","assign","WeakSet","payload","ms","timeoutId","setTimeout","finally","clearTimeout"],"mappings":"AAAO,MAAMA,EACTC,YAAYC,EAAIC,EAAMC,GAClBC,KAAKH,GAAKA,EACVG,KAAKF,KAAOA,EACZE,KAAKD,QAAUA,GACXA,aAAyC,EAASA,EAAQE,YAC1DD,KAAKE,OAAS,GACdF,KAAKG,eAAYC,EAExB,EAEE,SAASC,EAA6BC,EAAMC,GAC/C,IAAKD,IAASC,EACV,OAAO,EACX,MAAMC,EAAQC,OAAOC,KAAKJ,GACpBK,EAAQF,OAAOC,KAAKH,GAC1B,GAAIC,EAAMI,SAAWD,EAAMC,OACvB,OAAO,EAEX,IAAIC,EACJ,IAAKA,KAAOP,EACR,GAAIA,EAAKO,KAASN,EAAKM,GACnB,OAAO,EAGf,OAAO,CACX,CACO,SAASC,EAAeC,EAAQC,EAAUjB,GAC7C,IAAK,IAAIkB,EAAI,EAAGA,EAAIF,EAAOH,OAAQK,IAC/B,GAAIF,EAAOE,GAAGpB,KAAOmB,GACjBX,EAA6BU,EAAOE,GAAGlB,QAASA,GAChD,OAAOkB,EAGf,OAAQ,CACZ,CCnCA,IAcIC,EAAiCC,EAdjCC,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,GAAO,CAC3F,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,IAAW,MAAOG,GAAKL,EAAOK,GAAO,CAC9F,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,EAAO,KAIhBO,KAAKR,EAAWK,EAAY,CAC9GH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,OACtE,GACA,EACIO,EAAkE,SAAUC,EAAUC,EAAOC,EAAMC,GACnG,GAAa,MAATD,IAAiBC,EAAG,MAAM,IAAIC,UAAU,iDAC5C,GAAqB,mBAAVH,EAAuBD,IAAaC,IAAUE,GAAKF,EAAMI,IAAIL,GAAW,MAAM,IAAII,UAAU,4EACvG,MAAgB,MAATF,EAAeC,EAAa,MAATD,EAAeC,EAAEG,KAAKN,GAAYG,EAAIA,EAAEb,MAAQW,EAAMM,IAAIP,EACxF,EAGO,MAAMQ,EACTnD,YAAYG,GACR,IAAIiD,EAAIC,EACR/B,EAAgCgC,IAAIlD,MACpCA,KAAKmD,QAAU,GACfnD,KAAKoD,wBAA0B,CAC3BnD,SAAwF,QAA7E+C,EAAKjD,aAAyC,EAASA,EAAQE,gBAA6B,IAAP+C,GAAgBA,EAChHK,eAAoG,QAAnFJ,EAAKlD,aAAyC,EAASA,EAAQsD,sBAAmC,IAAPJ,EAAgBA,EAAK,GAErIjD,KAAKsD,QAAU,WACftD,KAAKuD,uBAAwB,EAC7BvD,KAAKwD,kBAAoB,EACzBxD,KAAKyD,OAAS,EACjB,CACDC,KAAKC,EAAWC,GACZ,IAAK5D,KAAKmD,QAAQQ,IAAiD,IAAnC3D,KAAKmD,QAAQQ,GAAW/C,OACpD,OAAO,EAEX,GAAqB,WAAjBZ,KAAKsD,QAGL,OAFItD,KAAKuD,uBACLvD,KAAKyD,OAAOI,KAAK,CAAEF,YAAWC,UAC3B,EAGX,IAAIE,EAAa,GACbC,GAAa,EA8BjB,OA5BA/D,KAAKmD,QAAQQ,GAAWK,SAASC,IAC7B,IAAIjB,EAAIC,EACR,IAAIiB,GAAU,EAEd,GAAID,EAAMlE,QAAQE,SAAU,CAC8C,QAArE+C,EAAKiB,aAAqC,EAASA,EAAM/D,cAA2B,IAAP8C,GAAyBA,EAAGa,KAAKD,GAC/G,MAAMP,EAAyD,QAAvCJ,EAAKgB,EAAMlE,QAAQsD,sBAAmC,IAAPJ,EAAgBA,EAAKjD,KAAKoD,wBAAwBC,gBACpHY,aAAqC,EAASA,EAAM/D,SAAW+D,EAAM/D,OAAOU,QAAUyC,IACvFY,EAAMpE,GAAGoE,EAAM/D,QACfgE,GAAU,EACVH,GAAa,EACb/D,KAAKmE,OAAO,OAAQR,EAAWM,EAAM/D,QACrC+D,EAAM/D,OAAS,GAEtB,MAGG+D,EAAMpE,GAAG+D,GACTM,GAAU,EACVH,GAAa,EACb/D,KAAKmE,OAAO,OAAQR,EAAWC,GAG7BK,EAAMnE,MAAQoE,GAChBJ,EAAWD,KAAKI,EACnB,IAELjE,KAAKmD,QAAQQ,GAAaG,EACnBC,CACV,CASDK,GAAGT,EAAW3C,EAAUjB,EAAUC,KAAKoD,yBAKnC,OAJKpD,KAAKmD,QAAQQ,KACd3D,KAAKmD,QAAQQ,GAAa,KAGf,IADH7C,EAAed,KAAKmD,QAAQQ,GAAY3C,EAAUjB,KAG9DC,KAAKmD,QAAQQ,GAAWE,KAAK,IAAIlE,EAAUqB,GAAU,EAAOjB,IAC5DC,KAAKmE,OAAO,KAAMR,EAAW3C,IACtB,EACV,CAUDlB,KAAK6D,EAAW3C,EAAUjB,EAAUC,KAAKoD,yBAKrC,OAJKpD,KAAKmD,QAAQQ,KACd3D,KAAKmD,QAAQQ,GAAa,KAGf,IADH7C,EAAed,KAAKmD,QAAQQ,GAAY3C,EAAUjB,KAG9DC,KAAKmD,QAAQQ,GAAWE,KAAK,IAAIlE,EAAUqB,GAAU,EAAMjB,IAC3DC,KAAKmE,OAAO,KAAMR,EAAW3C,IACtB,EACV,CASDqD,IAAIV,EAAW3C,EAAUjB,EAAUC,KAAKoD,yBACpC,IAAIkB,EAAQxD,EAAed,KAAKmD,QAAQQ,GAAY3C,EAAUjB,GAC9D,OAAe,IAAXuE,IAEJtE,KAAKmD,QAAQQ,GAAWY,OAAOD,EAAO,GACtCtE,KAAKmE,OAAO,MAAOR,EAAW3C,IACvB,EACV,CACDwD,MAAMb,EAAW3C,EAAUjB,GACvB,IAAIgE,GAAa,EACbU,EAA6B,GAkBjC,OAjBAzE,KAAKmD,QAAQQ,GAAWK,SAAQ,CAACC,EAAOS,KACpC,GAAIT,EAAMlE,QAAQE,WAAagE,aAAqC,EAASA,EAAM/D,SAAW+D,EAAM/D,OAAOU,OAAS,EAAG,CACnH,MAAM+D,EAAoB3D,GAAYA,IAAaiD,EAAMpE,GACnD+E,EAAiB7E,GAAWM,EAA6BN,EAASkE,EAAMlE,UACzD4D,GAAagB,GAAqBC,GAClDjB,IAAc3C,IAAajB,KAE5BkE,EAAMpE,GAAGoE,EAAM/D,QACf6D,GAAa,EACb/D,KAAKmE,OAAO,OAAQR,EAAWM,EAAM/D,QACrC+D,EAAM/D,OAAS,GACX+D,EAAMnE,MACN2E,EAA2BZ,KAAKa,GAE3C,KAEL1E,KAAKmD,QAAQQ,GAAa3D,KAAKmD,QAAQQ,GAAWkB,QAAO,CAACC,EAAGJ,KAASD,EAA2BM,SAASL,KACnGX,CACV,CAODiB,MAAMC,GAAiB,EAAMC,EAAmB,GAC5ClF,KAAKuD,sBAAwB0B,EAC7BjF,KAAKwD,kBAAoB0B,EACzBlF,KAAKsD,QAAU,QAClB,CAKD6B,SAEI,GADAnF,KAAKsD,QAAU,WACXtD,KAAKuD,sBAAuB,CAC5B,GAAIvD,KAAKwD,kBAAoB,EAAG,CAM5B,MALqB,KAAMpC,EAAUpB,UAAM,OAAQ,GAAQ,YACvD,IAAK,MAAMoF,KAAQpF,KAAKyD,aACdnB,EAAuBtC,KAAMkB,EAAiC,IAAKC,GAAwC0B,KAAK7C,KAAMoF,EAAMpF,KAAKwD,kBAE/J,IACuB6B,EACV,CAEGrF,KAAKyD,OAAOO,SAAQ,EAAGL,YAAWC,WAC9B5D,KAAK0D,KAAKC,EAAWC,EAAK,IAE9B5D,KAAKyD,OAAS,EAErB,CACJ,CACD6B,QAAQ3B,GACJ,IAAIX,EACAW,IAAiD,QAAlCX,EAAKhD,KAAKmD,QAAQQ,UAA+B,IAAPX,OAAgB,EAASA,EAAGpC,QAAU,GAC/FZ,KAAKmD,QAAQQ,GAAa,GAC1B3D,KAAKyD,OAASzD,KAAKyD,OAAOoB,QAAQ7C,GAAMA,EAAE2B,YAAcA,MAGxD3D,KAAKyD,OAAS,GACdzD,KAAKmD,QAAU,GAEtB,CACDoC,UAAU5B,GACN,YAAkBvD,IAAduD,EACO3D,KAAKmD,QAGLnD,KAAKmD,QAAQQ,GAAW6B,KAAKvB,GAAUA,EAAMpE,IAE3D,CAUD4F,YAAY9B,EAAW3C,EAAUjB,EAAUC,KAAKoD,yBAC5C,OAAOpD,KAAKoE,GAAGT,EAAW3C,EAAUjB,EACvC,CASD2F,eAAe/B,EAAW3C,EAAUjB,EAAUC,KAAKoD,yBAC/C,OAAOpD,KAAKqE,IAAIV,EAAW3C,EAAUjB,EACxC,CACDoE,OAAOwB,EAAMhC,EAAWiC,GACpB,GAAc,SAATD,IAAoB5C,EAAqB8C,aAAanC,MAC7C,OAATiC,IAAkB5C,EAAqB8C,aAAazB,IAC3C,QAATuB,IAAmB5C,EAAqB8C,aAAaxB,IACtD,OACJ,GAAa,SAATsB,EACA,IACIC,EAAYE,KAAKC,UAAUH,EAI9B,CAFD,MAAO5C,GACH4C,EAAY,uDAAuDnF,OAAOC,KAAKkF,GAAWI,KAAK,MAClG,KAEa,OAATL,GAAsC,mBAAdC,IAC7BA,EAAYA,EAAUK,YAE1B,MAAMC,EAAc,IAAIC,KAClBC,EAAU,GAAGF,EAAYG,cAAcH,EAAYI,gBAAgBJ,EAAYK,gBAAgBL,EAAYM,oBACjHC,QAAQC,eAAe,kBAAkBf,mBAAsBhC,OAAeyC,KAAY,gCAC1FK,QAAQE,IAAI,kBAAkBf,MAAe,mCAC7Ca,QAAQG,UACX,CAKDC,mBAAmBC,GACf/D,EAAqB8C,aAAepF,OAAOsG,OAAOtG,OAAOsG,OAAO,CAAA,EAAIhE,EAAqB8C,cAAeiB,EAC3G,EAEL5F,EAAkC,IAAI8F,QAAW7F,EAAyC,SAAgD8F,EAASC,GAC/I,IAAIC,EACJ,OAAO,IAAI1F,SAASC,GAAayF,EAAYC,YAAW,KACpDpH,KAAK0D,KAAKuD,EAAQtD,UAAWsD,EAAQrD,MACrClC,GAAQ,EAAK,GACdwF,KAAMG,SAAQ,KACbC,aAAaH,EAAU,GAE/B,EACApE,EAAqB8C,aAAe,CAAEnC,MAAM,EAAOU,IAAI,EAAOC,KAAK"}